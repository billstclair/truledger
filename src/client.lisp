; -*- mode: lisp -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; A Trubanc client API. Talks the protocol of server.lisp
;;;

(in-package :trubanc)

(defun make-client (dir)
  (let ((db (make-fsdb dir)))
    (make-instance 'client :db db)))

(defclass client ()
  ((db :type db
       :initarg :db
       :accessor db)
   (parser :type (or parser null)
           :initform nil
           :accessor parser)
   (pubkeydb :type (or pubkeydb nill)
             :initform nil
             :accessor pubkeydb)

  ;; Initialized by login() and newuser()
   (id :type (or string null)
       :initform nil
       :accessor id)
   (privkey :initform nil
            :accessor privkey)
   (pubkey :initform nil
           :accessor pubkey)

   ;; initialized by setbank() and addbank()
   (server :type (or server null)
           :initform nil
           :accessor server)
   (bankid :type (or string null)
           :initform nil
           :accessor bankid)

   ;; Set true by getreq()
   (syncedreq-p :type boolean
                :initform nil
                :accessor syncedreq-p)

   ;; True to make process() print the messages it sends and receives
   (showprocess-p :type boolean
                  :initform nil
                  :accessor showprocess-p)

   ;; The last coupon generated by a spend:
   ;; (<bankid>,couponenvelope,<id>,<encrypted-coupon>)
   (coupon :type (or string null)
           :initform nil
           :accessor coupon)

   ;; The last outbox time generated by a spend
   (last-spend-time :type (or string null)
                    :initform nil
                    :accessor last-spend-time)

   ;; Set true to keep history of spend & processinbox
   (keep-history-p :type boolean
                   :initform nil
                   :accessor keep-history-p)

   ;; Used to accumulate timing information from server (perf.lisp)
   (server-times :type (or hash-table null)
                 :initform nil
                 :accessor server-times)))

(defmethod :initialize-instance :after ((client client) &rest rest)
  (declare (ignore rest))
  (setf (pubkeydb client)
        (make-instance 'pubkeydb
                       :client client
                       :db (db-subdir (db client) $PUBKEY))
        (parser client)
        (make-instance 'parser :keydb (pubkeydb client)))
  (setf (parser-always-verify-sigs-p (parser client)) t))

;; API Methods

(defmethod newuser ((client client) &key passphrase (privkey 3072))
  "Create a new user with the given passphrase, error if already there.
   If privkey is a string, use that as the private key.
   If it is an integer, default 3072, create a new private key with that many bits
   User is logged in when this returns successfully."
  (let ((db (db client))
        (hash (passphrase-hash passphrase)))

    (logout client)

    (when (db-get db $PRIVKEY hash)
      (error "Passphrase already has an associated private key"))

    (when (integerp privkey)
      ;; privkey is size in bits for new private key
      (setq privkey (rsa-generate-key privkey)))

    (let* ((pubkey (encode-rsa-public-key privkey))
           (id (pubkey-id pubkey))
           (privkey-str (encode-rsa-private-key privkey passphrase)))
      (setf (db-get db $PRIVKEY hash) privkey-str)
      (db-put db (pubkey-key id) (format nil "~a~%" (trim pubkey)))

      (setf (id client) id
            (privkey client) privkey
            (pubkey client) pubkey))))

(defmethod get-privkey ((client client) passphrase)
  (let ((db (db client))
        (hash (passphrase-hash passphrase)))
    (decode-rsa-private-key
     (or (db-get db $PRIVKEY hash)
         (error "No account for passphrase in database"))
     passphrase)))

(defmethod login ((client client) passphrase)
  "Log in with the given passphrase. Error if no user associated with passphrase."
  (let* ((privkey (get-privkey client passphrase))
         (pubkey (encode-rsa-public-key privkey))
         (id (pubkey-id pubkey)))
    (setf (id client) id
          (privkey client) privkey
          (pubkey client) pubkey)))

(defmethod login-with-sessionid ((client client) sessionid)
  (let ((passphrase (session-passphrase client sessionid)))
    (unwind-protect (login client passphrase)
      (destroy-password passphrase))
    (setf (syncedreq-p client) t))) ;; no server sync for session login

(defmethod login-new-session ((client client) passphrase)
  "Login, create a new session, and return a sessionid."
    (login client passphrase)
    (make-session client passphrase))

(defmethod logout ((client client))
  (when (id client)
    (remove-session client)
    (setf (id client) nil))
  (let ((privkey (privkey client)))
    (when privkey
      (setf (privkey client) nil)
      (rsa-free privkey))
    (setf (bankid client) nil
          (server client) nil)))

;; All the API methods below require the user to be logged in.
;; id and privkey must be set.

(defmethod current-user ((client client))
  "Return current user ID if logged in, otherwise nil."
  (and (privkey client) (id client)))

(defmethod require-current-user ((client client))
  (or (current-user client) (error "Not logged in")))

(defmethod user-pubkey ((client client) &optional (id (id client)))
  "Return pubkey of a user, default logged-in user"
  (let ((db (db client)))
    (and id (db-get db $PUBKEY id))))

(defstruct bank
  id
  name
  url)

(defmethod getbank ((client client) bankid &optional all)
  "Returns a BANK instance, or NIL if it doesn't find the BANKID.
   If ALL is true, return the bank even if the current user isn't logged in."
  (and (or all (userreq client bankid))
       (make-bank :id bankid
                  :name (bankprop client $NAME bankid)
                  :url (bankprop client $URL bankid))))

(defmethod getbanks ((client client) &optional all)
  "Return all the banks known by the current user,
   as a list of BANK instances.
   (BANK-PUBKEYSIG BANK) will be blank if the user has no account at BANK."
  (let* ((db (db client))
         (id (require-current-user client))
         (banks (db-contents db (strcat $ACCOUNT "/" id "/" $BANK)))
         (res nil))
    (dolist (bank banks)
      (let ((bank (getbank client bankid all)))
        (when bank (push bank res))))

    (sort (nreverse res) 'string-lessp :key #'bank-name)))

(defun url-p (url)
  "Returns true if $url might be a properly-fored URL."
  (and (stringp url)
       (>= (length url) 5)
       (or (string-equal (subseq url 0 5) "http:")
           (and (>= (length url) 6)
                (string-equal (subseq url 0 6) "https:")))))

(defun parse-coupon (coupon)
  "Parse a coupon into bankid, url, and coupon number.
   Returns three values:
     1) bankid
     2) url
     3) coupon-number
   Coupon can be [$url,$coupon_number] or
   ($bankid,coupon,$url,$coupon_number,$asset,$amount,note:$note)"
  (unless (stringp coupon)
    (error "Coupon not a string"))

  ;; Coupon can be just [$url,$coupon_number]
  (setq coupon (trim coupon))
  (let (bankid url coupon-number)
    (cond ((and (> (length coupon) 0)
                (eql (aref coupon 0) #\[))
           (unless (eql #\] (aref coupon (1- (length coupon))))
             (error "Malformed coupon string"))
           (let* ((a (explode #\, (subseq coupon 1 (1- (length coupon))))))
             (unless (eql (length a) 2)
               (error "Malformed coupon string"))
             (setq bankid ""
                   url (trim (car a))
                   coupon-number (trim (cadr a)))))
          (t (let* ((parse (tokenize coupon))
                    (items (print (map 'vector 'cdr parse))))
               ; [$id,coupon,$bankid,
               (unless (>= (length items) 7)
                 (error "Malformed coupon message, < 7 tokens"))
               (unless (equal (elt items 0) #\()
                 (error "Message doesn't start with left paren"))
               (setq bankid (elt items 1)
                     url (elt items 5)
                     coupon-number (elt items 7))
               (unless (id-p bankid)
                 (error "Coupon bankid not an id"))
               (unless (equal #\, (aref items 2))
                 (error "Coupon missing comma 1"))
               (unless (equal (elt items 3) $COUPON)
                 (error "Coupon isn't a coupon message"))
               (unless (equal (aref items 4) #\,)
                 (error "Coupon missing comma 2")))))
    (unless (url-p url)
      (error "Coupon url isn't a url: ~s" url))
    (unless (coupon-number-p coupon-number)
      (error "Coupon number malformed: ~a" coupon-number))
    (values bankid url coupon-number)))

#||
;; Continue here

  // Verify that a message is a valid coupon.
  // Check that it is actually signed by the bank that it
  // claims to be from.
  // Ask the bank whether a coupon of that number exists.
  function verifycoupon($coupon, $bankid, $url) {
    $t = $this->t;
    $u = $this->u;
    $parser = $this->parser;

    $err = $this->verifybank($url, $bankid);
    if ($err) return "verifycoupon: $err";
    $coupon = trim($coupon);
    if (substr($coupon, 0, 1) == '[') {
      $err = $this->parsecoupon($coupon, $ignore, $ignore, $coupon_number);
      if ($err) return $err;
    } else {
      $args = $this->unpack_bankmsg($coupon, $t->COUPON, $bankid);
      if (is_string($args)) return $args;
      $coupon_number = $args[$t->COUPON];
    }
    if (!$u->is_coupon_number($coupon_number)) {
      return "Malformed coupon number: $coupon_number";
    }
    $msg = "(0," . $t->BANKID . ",0,$coupon_number):0";
    $server = new serverproxy($url, $this);
    $msg = $server->process($msg);

    $reqs = $parser->parse($msg);
    if (!$reqs) return "verifycoupon: " . $parser->errmsg;
    $args = $this->match_bankreq($reqs[0], $t->REGISTER, $bankid);
    if (is_string($args)) return "verifycoupon: $args";
    if (count($reqs) != 2) return "verifycoupon: expected 2 messages from bank";
    $args = $this->match_bankreq($reqs[1], $t->COUPONNUMBERHASH, $bankid);
    if (is_string($args)) return "$args";

    return false;
  }

  // Verify that a bank matches its URL.
  // Add the bank to our database if it's not there already
  // Set $id arg to $bankid, if false, or
  // compare it to the bankid returned from URL.
  function verifybank($url, &$id) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->isurl($url)) return "Not a URL: $url";

    // Hash the URL to ensure its name will work as a file name
    $urlhash = sha1($url);
    $urlkey = $t->BANK . '/' . $t->BANKID;
    $bankid = $db->get("$urlkey/$urlhash");
    if ($bankid) {
      if ($id && $id != $bankid) return "verifybank: id <> bankid";
      if (!$id) $id = $bankid;
    } else {
      $u = $this->u;
      $ssl = $this->ssl;
      $parser = $this->parser;

      $msg = '(0,' . $t->BANKID . ',0):0';
      $server = new serverproxy($url, $this);
      $msg = $server->process($msg);
      $savebankid = $this->bankid;
      $this->bankid = $bankid;
      $args = $u->match_message($msg);
      $this->bankid = $savebankid;
      if (is_string($args)) {
        return "verifybank: Bank's bankid response error: $args";
      }
      $bankid = $args[$t->CUSTOMER];
      if ($args[$t->REQUEST] != $t->REGISTER) {
        return "Bank URL unresponsive or not a Trubanc server";
      }
      if ($bankid != $args[$t->BANKID]) {
        return "Bank's register message malformed";
      }
      if (!$id) $id = $bankid;
      elseif ($bankid != $id) return "Bankid different than expected";
      $pubkey = $args[$t->PUBKEY];
      $name = $args[$t->NAME];
      if ($ssl->pubkey_id($pubkey) != $bankid) {
        return "verifybank: Bank's id doesn't match its public key";
      }
      if ($id && $id != $bankid) return "verifybank: id <> bankid";
      if (!$id) $id = $bankid;
      $ourl = $this->bankprop($t->URL, $bankid);
      if (!$ourl) {
        // Initialize the bank in the database
        $db->put("$urlkey/$urlhash", $bankid);
        $db->put($this->bankkey($t->URL, $bankid), $url);
        $db->put($this->bankkey($t->NAME, $bankid), $name);
        $db->put($this->pubkeykey($bankid), trim($pubkey) . "\n");
      }
    }

    return false;
  }

  // Add a bank with the given $url to the database.
  // $url can be a coupon to redeem that with registration.
  // No error, but does nothing, if the bank is already there.
  // If the bank is NOT already there, registers with the given $name and $coupons.
  // If registration fails, removes the bank and you'll have to add it again
  // after getting enough usage tokens at the bank to register.
  // Sets the client instance to use this bank until addbank() or setbank()
  // is called to change it.
  // If $couponok is true, does not verify a coupon with the bank before using it.
  function addbank($url, $name='', $couponok=false) {
    $db = $this->db;
    $t = $this->t;

    if (!$this->current_user()) return "Not logged in";

    $bankid = false;
    $realurl = false;
    $coupon = false;
    $err = $this->parsecoupon($url, $bankid, $realurl, $coupon_number);
    if (is_string($err)) {
      $err = $this->verifybank($url, $bankid);
      if ($err) return $err;
    } else {
      if (!$bankid) {
        $err = $this->verifybank($realurl, $bankid);
        if ($err) return $err;
      }
      if (!$couponok) {
        $err = $this->verifycoupon($url, $bankid, $realurl);
        if ($err) return "$err";
      }
      $coupon = $coupon_number;
    }
    $err = $this->setbank($bankid, false);
    if (!$err) {
      // User already has an account at this bank.
      // Redeem the coupon
      $err = false;
      if ($coupon) $err =$this->redeem($coupon);
      return $err;
    }

    $oldbankid = $this->bankid;
    $oldserver = $this->server;

    $this->bankid = $bankid;
    $url = $this->bankprop($t->URL, $bankid);
    if (!$url) return "URL not stored for verified bank: $bankid";
    $this->server = new serverproxy($url, $this);
    $err = $this->register($name, $coupon, $bankid);
    if ($err) {
      $db->put($this->userreqkey($bankid), '');
      $this->bankid = false;
      $this->bankid = $oldbankid;
      $this->server = $oldserver;
      return $err;
    }

    return false;
  }

  // Set the bank to the given id.
  // Sets the client instance to use this bank until addbank() or setbank()
  // is called to change it, by setting $this->bankid and $this->server
  function setbank($bankid, $check=true) {
    $db = $this->db;
    $t = $this->t;
    $u = $this->u;

    if (!$this->current_user()) return "Not logged in";

    $url = $this->bankprop($t->URL, $bankid);
    if (!$url) {
      return "Bank not known: $bankid";
    }

    $req = $this->userbankprop($t->REQ, $bankid);
    if ($req === '' || $req === false) {
      return "User not registered at bank";
    }

    $this->bankid = $bankid;
    $server = new serverproxy($url, $this);
    $this->server = $server;

    if ($check) {
      $msg = $this->sendmsg($t->BANKID, $this->pubkey);
      $args = $u->match_message($msg);
      if (is_string($args)) {
        $this->bankid = false;
        return "setbank: Bank's bankid response error: $args";
      }
      if ($bankid != $args[$t->CUSTOMER]) {
        $this->bankid = false;
        $new = $args[$t->CUSTOMER];
        return "bankid changed since we last contacted this bank, old: $bankid, new: $new";
      }
      if ($args[$t->REQUEST] != $t->REGISTER ||
          $args[$t->BANKID] != $bankid) {
        $this->bankid = false;
        return "Bank's bankid message wrong: $msg";
      }
    }

    return false;
  }

  // Return current bank if the user is logged in and the bank is set, else false.
  function current_bank() {
    if ($this->current_user() && $this->server) return $this->bankid;
    return false;
  }

  // All the API methods below require the user to be logged and the bank to be set.
  // Do this by calling newuser() or login(), and addbank() or setbank().
  // $this->id, $this->privkey, $this->bankid, & $this->server must be set.

  // Register at the current bank.
  // No error if already registered
  // If not registered, and $coupons is a string or array of strings,
  // assumes the string(s) are coupons, encrypts and signs them,
  // and sends them to the bank with the registration request.
  function register($name='', $coupons=false, $bankid=false) {
    $t = $this->t;
    $u = $this->u;
    $db = $this->db;
    $id = $this->id;
    $ssl = $this->ssl;

    if (!$bankid) {
      $bankid = $this->bankid;
      $server = $this->server;
    } else {
      $url = $this->bankprop($t->URL);
      if (!$url) return "In register: Unknown bankid";
      $server = new serverproxy($url, $this);
    }

    if (!$this->current_bank()) return "In register(): Bank not set";

    // If already registered and we know it, nothing to do
    if ($db->get($this->userbankkey($t->PUBKEYSIG, $bankid) . "/$id")) return false;

    // See if bank already knows us
    // Resist the urge to change this to a call to
    // get_pubkey_from_server. Trust me.
    $msg = $this->custmsg($t->ID, $bankid, $id);
    $msg = $server->process($msg);
    $args = $this->unpack_bankmsg($msg, $t->ATREGISTER);
    if (is_string($args)) {
      // Bank doesn't know us. Register with bank.
      $msg = $this->custmsg($t->REGISTER, $bankid, $this->pubkey($id), $name);
      if ($coupons) {
        if (is_string($coupons)) $coupons = array($coupons);
        $pubkey = $this->pubkeydb->get($bankid);
        if (!$pubkey) return "Can't get bank public key";
        foreach ($coupons as $coupon) {
          $coupon = $ssl->pubkey_encrypt($coupon, $pubkey);
          $msg .= '.' . $this->custmsg($t->COUPONENVELOPE, $bankid, $coupon);
        }
      }
      $msg = $server->process($msg);
      $args = $this->unpack_bankmsg($msg, $t->ATREGISTER);
      if (is_string($args)) return "Registration failed: $args";
    }

    // Didn't fail. Notice registration here
    $args = $args[$t->MSG];
    if ($args[$t->CUSTOMER] != $id ||
        $args[$t->REQUEST] != $t->REGISTER ||
        $args[$t->BANKID] != $bankid) return "Malformed registration message";
    $pubkey = $args[$t->PUBKEY];
    $keyid = $ssl->pubkey_id($pubkey);
    if ($keyid != $id) return "Server's pubkey wrong";
    $db->put($this->userbankkey($t->PUBKEYSIG) . "/$id", $msg);
    $db->put($this->userbankkey($t->REQ), -1);

    return false;
  }

  // Get contacts for the current bank.
  // Contacts are sorted by nickname, name, id
  // Returns an error string or an array of items of the form:
  //
  //   array($t->ID => $id,
  //         $t->NAME => $name,
  //         $t->NICKNAME => $nickname,
  //         $t->NOTE => $note)
  function getcontacts() {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In getcontacts(): Bank not set";

    $lock = $db->lock($this->userreqkey());
    $res = $this->getcontacts_internal();
    $db->unlock($lock);

    return $res;
  }

  // General comparison function on array element
  function comparearrays($a1, $a2, $keys, $comparer='strcasecmp') {
    foreach ($keys as $key) {
      $res = $comparer($a1[$key], $a2[$key]);
      if ($res != 0) return $res;
    }
    return 0;
  }

  // For usort in getcontacts_internal
  function comparecontacts($c1, $c2) {
    $t = $this->t;

    return $this->comparearrays
      ($c1, $c2, array($t->NICKNAME, $t->NAME, $t->ID));
  }

  function getcontacts_internal() {
    $t = $this->t;
    $db = $this->db;
    
    $ids = $db->contents($this->contactkey());
    $res = array();
    foreach ($ids as $otherid) {
      $contact = $this->getcontact_internal($otherid, false, false);
      if ($contact) $res[] = $contact;
    }
    usort($res, array("client", "comparecontacts"));
    return $res;
  }

  // Get a contact, by ID.
  // Return:
  //   array($t->ID => $id,
  //         $t->NAME => $name,
  //         $t->NICKNAME => $nickname,
  //         $t->NOTE => $note,
  //         $t->CONTACT => $iscontact)
  // or false, if can't find that contact.
  function getcontact($otherid, $add=false) {
    $t = $this->t;
    $db = $this->db;
    
    if (!$this->current_bank()) return false;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getcontact_internal($otherid, $add);
    $db->unlock($lock);

    return $res;
  }

  function getcontact_internal($otherid, $add=false, $probebank=true) {
    $t = $this->t;
    $db = $this->db;
    
    $pubkeysig = $this->contactprop($otherid, $t->PUBKEYSIG);
    if (!$pubkeysig) {
      if ($add) {
        $this->addcontact_internal($otherid);
        $pubkeysig = $this->contactprop($otherid, $t->PUBKEYSIG);
      } elseif ($probebank) {
        return $this->get_id($otherid);
      }
    }
    if (!$pubkeysig) return false;
    $res = array($t->ID => $otherid,
                 $t->NAME => $this->contactprop($otherid, $t->NAME),
                 $t->NICKNAME => $this->contactprop($otherid, $t->NICKNAME),
                 $t->NOTE => $this->contactprop($otherid, $t->NOTE),
                 $t->CONTACT => true);
    return $res;
  }
  
  // Add a contact to the current bank.
  // If it's already there, change its nickname and note, if included
  function addcontact($otherid, $nickname=false, $note=false) {
    $t = $this->t;
    $db = $this->db;

    $lock = $db->lock($this->userreqkey());
    $res = $this->addcontact_internal($otherid, $nickname, $note);
    $db->unlock($lock);

    return $res;
  }

  function addcontact_internal($otherid, $nickname=false, $note=false) {
    $t = $this->t;
    $db = $this->db;

    $pubkeydb = $this->pubkeydb;
    $bankid = $this->bankid;
    $ssl = $this->ssl;

    if (!$this->current_bank()) return "In addcontact(): Bank not set";

    if ($this->contactprop($otherid, $t->PUBKEYSIG)) {
      if ($nickname) $db->put($this->contactkey($otherid, $t->NICKNAME), $nickname);
      if ($note) $db->put($this->contactkey($otherid, $t->NOTE), $note);
      return false;
    }

    $args = $this->get_id($otherid);
    if (!$args) return "Can't find id at bank: $otherid";
    $msg = $args[$t->MSG];
    $name = $args[$t->NAME];

    if (!$nickname) $nickname = $name ? $name : 'anonymous';
    $db->put($this->contactkey($otherid, $t->NICKNAME), $nickname);
    $db->put($this->contactkey($otherid, $t->NOTE), $note);
    $db->put($this->contactkey($otherid, $t->NAME), $name);
    $db->put($this->contactkey($otherid, $t->PUBKEYSIG), $msg);
  }

  // Delete a contact from the current bank.
  function deletecontact($otherid) {
    $t = $this->t;
    $db = $this->db;

    $lock = $db->lock($this->userreqkey());
    $res = $this->deletecontact_internal($otherid);
    $db->unlock($lock);

    return $res;
  }

  function deletecontact_internal($otherid) {
    $t = $this->t;
    $db = $this->db;

    $key = $this->contactkey($otherid);
    $contents = $db->contents($key);
    foreach ($contents as $k) {
      $db->put("$key/$k", '');
    }

    return false;
  }

  // Check for an id at the bank. Return false if not there.
  // Return array($t->PUBKEY => $pubkey,
  //              $t->NAME => $name)
  function get_id($id) {
    $t = $this->t;
    $db = $this->db;
    $bankid = $this->bankid;
    $ssl = $this->ssl;

    if (!$bankid) return false;

    $key = $this->userbankkey($t->PUBKEYSIG) . "/$id";
    $msg = $db->get($key);
    $needstore = false;
    if (!$msg) {
      $msg = $this->sendmsg($t->ID, $bankid, $id);
      $needstore = true;
    }    
    $args = $this->unpack_bankmsg($msg, $t->ATREGISTER);
    if (is_string($args)) return false;
    $args = $args[$t->MSG];
    $pubkey = $args[$t->PUBKEY];
    if ($id != $ssl->pubkey_id($pubkey)) return false;

    if ($needstore) $db->put($key, $msg);

    $res = array();
    $res[$t->ID] = $args[$t->CUSTOMER];
    $res[$t->PUBKEY] = $args[$t->PUBKEY];
    $res[$t->NAME] = $args[$t->NAME];
    $res[$t->MSG] = $msg;

    return $res;
  }

  // GET sub-account names.
  // Returns an error string or an array of the sub-account names
  function getaccts() {
    $db = $this->db;

    if (!$this->current_bank()) return "In getaccts(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;
    
    $res = $db->contents($this->userbalancekey());
    usort($res, array('client', 'compareaccts'));
    return $res;
  }

  // For usort in getassets
  function compareassets($c1, $c2) {
    $t = $this->t;

    return $this->comparearrays($c1, $c2, array($t->ASSETNAME, $t->ASSET));
  }

  // Return the assets for which the customer has balances
  // array($assetid => <getasset() result>, ...)
  function getassets() {
    $db = $this->db;
    $t = $this->t;

    $res = array();
    $bankid = $this->bankid;

    if ($bankid) {
      $key = $this->userbalancekey();
      $accts = $db->contents($key);
      foreach ($accts as $acct) {
        $assetids = $db->contents("$key/$acct");
        foreach ($assetids as $assetid) {
          if (!isset($res[$assetid])) {
            $asset = $this->getasset($assetid);
            if ($asset) $res[$assetid] = $asset;
          }
        }
      }
    }

    uasort($res, array("client", "compareassets"));
    return $res;
  }

  // Look up an asset.
  // Returns an error string or an array of items of the form:
  //
  //   array($t->ID => $issuerid,
  //         $t->ASSET => $assetid,
  //         $t->SCALE => $scale,
  //         $t->PRECISION => $precision,
  //         $t->ASSETNAME => $assetname,
  //         $t->PERCENT => $percent
  //         $t->ISSUER => $issuer)
  //
  // If the asset isn't found in the client database, looks it up on the
  // server, and stores it in the client database.
  function getasset($assetid, $forceserver=false) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In getacct(): Bank not set";

    $key = $this->assetkey($assetid);
    $lock = $db->lock($key, true);
    $msg = $forceserver ? false : $db->get($key);
    if ($msg) {
      $db->unlock($lock);
      $args = $this->unpack_bankmsg($msg, $t->ATASSET);
      if (is_string($args)) return "While matching asset: $args";
    } else {
      $args = $this->getasset_internal($assetid, $key);
      $db->unlock($lock);
      if (is_string($args)) return $args;
    }
    $reqs = @$args[$this->unpack_reqs_key][1];
    $args = $args[$t->MSG];
    $percent = false;
    $issuer = false;
    if ($reqs) {
      $args1 = $this->match_bankreq($reqs, $t->ATSTORAGE);
      if (is_string($args1)) return "While matching storage fee: $args1";
      $args1 = $args1[$t->MSG];
      $issuer = $args1[$t->CUSTOMER];
      $percent = $args1[$t->PERCENT];
    }

    return array($t->ID => $args[$t->CUSTOMER],
                 $t->ASSET => $assetid,
                 $t->SCALE => $args[$t->SCALE],
                 $t->PRECISION => $args[$t->PRECISION],
                 $t->ASSETNAME => $args[$t->ASSETNAME],
                 $t->ISSUER => $issuer,
                 $t->PERCENT => $percent);
  }

  function getasset_internal($assetid, $key) {
    $t = $this->t;
    $db = $this->db;

    $bankid = $this->bankid;
    $req = $this->getreq();
    if (!$req) return "Couldn't get req for getasset";
    $msg = $this->sendmsg($t->GETASSET, $bankid, $req, $assetid);
    $args = $this->unpack_bankmsg($msg, $t->ATASSET);
    if (is_string($args)) return "While downloading asset: $args";
    $msgargs = $args[$t->MSG];
    if ($msgargs[$t->REQUEST] != $t->ASSET ||
        $msgargs[$t->BANKID] != $bankid ||
        $msgargs[$t->ASSET] != $assetid) {
      return "Bank wrapped wrong object with @asset";
    }
    $db->put($key, $msg);
    return $args;
  }

  function addasset($scale, $precision, $assetname, $percent=false) {
    $t = $this->t;
    $db = $this->db;

    $lock = $db->lock($this->userreqkey());
    $res = $this->addasset_internal($scale, $precision, $assetname, $percent);
    $db->unlock($lock);

    if ($res) $this->forceinit();

    return $res;
  }

  function addasset_internal($scale, $precision, $assetname, $percent) {
    $t = $this->t;
    $u = $this->u;
    $db = $this->db;
    $id = $this->id;
    $bankid = $this->bankid;
    $server = $this->server;
    $parser = $this->parser;

    if (!$id || !$bankid) return "Can't add asset unless bank is set";

    $assetid = $u->assetid($id, $scale, $precision, $assetname);
    $time = $this->gettime();
    if (!$time) return "While adding asset: can't get timestamp";
    $fees = $this->getfees();
    if (is_string($fees)) return "While adding asset: $fees";
    $tranfee = $fees[$t->TRANFEE];
    $tokenid = $tranfee[$t->ASSET];
    
    $process = $this->custmsg($t->ASSET, $bankid, $assetid, $scale, $precision, $assetname);
    $bal1 = $this->getbalance($t->MAIN, $tokenid);
    if (is_string($bal1)) return $bal1;
    $bal1 = $bal1[$t->AMOUNT];
    $oldasset = $this->getasset($assetid);
    $oldasset = !is_string($oldasset);
    if ($id == $bankid) $bal1 = '';
    else {
      $tokens = !$oldasset ? 2 : 1;
      $ispos = (bccomp($bal1, 0) >= 0);
      $bal1 = bcsub($bal1, $tokens);
      if ($ispos && (bccomp($bal1, 0) < 0)) {
        if ($oldasset) return "You need 1 usage token to update an asset";
        return "You need 2 usage tokens to create a new asset";
      }
      $bal1 = $this->custmsg($t->BALANCE, $bankid, $time, $tokenid, $bal1);
    }
    $bal2 = false;
    if (!$oldasset) $bal2 = $this->custmsg($t->BALANCE, $bankid, $time, $assetid, -1);

    $acctbals = array();
    if ($bal1) $acctbals[$t->MAIN][$tokenid] = $bal1;
    if ($bal2) $acctbals[$t->MAIN][$assetid] = $bal2;
    $balancehash = $this->balancehashmsg($time, $acctbals);

    $msg = $process;
    if ($percent) {
      $storage = $this->custmsg($t->STORAGE, $bankid, $time, $assetid, $percent);
      $msg .= ".$storage";
    }
    if ($bal1) $msg .= ".$bal1";
    if ($bal2) $msg .= ".$bal2";
    $msg .= ".$balancehash";
    $msg = $server->process($msg);

    // Request sent. Check for error
    $reqs = $this->parser->parse($msg);
    if (!$reqs) return "While adding asset: " . $parser->errmsg;
    $gotbal1 = $gotbal2 = $gotstorage = false;
    foreach ($reqs as $req) {
      $args = $this->match_bankreq($req);
      if (is_string($args)) return "While adding asset: $args";
      if ($args[$t->REQUEST] == $t->FAILED) {
        return "Server error while adding asset: " . $args[$t->ERRMSG];
      }
      $msg = $parser->get_parsemsg($req);
      $m = $args[$t->MSG];
      $m = trim($parser->get_parsemsg($m));
      if ($m == $bal1) $gotbal1 = $msg;
      elseif ($m == $bal2) $gotbal2 = $msg;
      elseif ($m == $storage) $gotstorage = $msg;
    }

    if (!(($gotbal1 || (!$bal1)) && ($gotbal2 || (!$bal2)))) {
      return "While adding asset: missing returned balance from server";
    }
    if ($percent && !$gotstorage) {
      return "While adding asset: storage fee not returned from server";
    }

    // All is well. Commit the balance changes
    if ($bal1) $db->put($this->userbalancekey($t->MAIN, $tokenid), $gotbal1);
    if ($bal2) $db->put($this->userbalancekey($t->MAIN, $assetid), $gotbal2);

    $this->getasset($assetid, true);

    return false;
  }

  // Look up the transaction cost.
  // Returns an error string or an array of the form:
  //
  //   array($t->TRANFEE => ARRAY(ARRAY($t->ASSET => $assetid,
  //                                    $t->AMOUNT => $amount),
  //                              ...),
  //         $t->REGFEE => ARRAY(ARRAY($t->ASSET => $assetid,
  //                                   $t->AMOUNT => $assetid),
  //                             ...),
  //         $t->FEE|<operation> => ARRAY(ARRAY($t->ASSET => $assetid,
  //                                            $t->AMOUNT => $assetid),
  //                                      ...),
  //         ...)
  //
  // Currently, only the tranfee and regfee are supported by the server,
  // and only a single fee, in usage tokens, is charged for each.
  // So that's all the spend code handles.
  //
  // If the asset isn't found in the client database, looks it up on the
  // server, and stores it in the client database.
  function getfees($reload=false) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In getfees(): Bank not set";

    $key = $this->tranfeekey();
    $lock = $db->lock($key, true);
    $msg = $db->get($key);
    if ($msg) {
      $db->unlock($lock);
      $args = $this->unpack_bankmsg($msg, $t->TRANFEE);
      if (is_string($args)) return "While matching tranfee: $args";
    } else {
      $args = $this->getfees_internal($key);
      $db->unlock($lock);
      if (is_string($args)) return $args;
    }

    $tranfee = array($t->ASSET => $args[$t->ASSET],
                     $t->AMOUNT => $args[$t->AMOUNT]);

    $msg = $this->regfee();
    if (!$msg) return "Regfee not initialized";
    $args = $this->unpack_bankmsg($msg, $t->REGFEE);
    if (is_string($args)) return "While matching regfee: $args";

    $regfee = array($t->ASSET => $args[$t->ASSET],
                    $t->AMOUNT => $args[$t->AMOUNT]);

    return array($t->TRANFEE => $tranfee,
                 $t->REGFEE => $regfee);
  }

  function getfees_internal($key) {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;
    $bankid = $this->bankid;

    $req = $this->getreq();
    if (!$req) return "Couldn't get req for getfees";
    $msg = $this->sendmsg($t->GETFEES, $bankid, $req);
    $reqs = $parser->parse($msg);
    if (!$reqs) return "While parsing getfees return message: " . $parser->errmsg;
    $feeargs = false;
    foreach ($reqs as $req) {
      $args = $this->match_bankreq($req);
      if (is_string($args)) return "While matching getfees return: $args";
      if ($args[$t->REQUEST] == $t->TRANFEE) {
        $db->put($key, $parser->get_parsemsg($req));
        $feeargs = $args;
      } elseif ($args[$t->REQUEST] == $t->REGFEE) {
        $db->put($this->regfeekey(), $parser->get_parsemsg($req));
      }
    }

    if (!$feeargs) $feeargs = "No tranfee from getfees request";
    return $feeargs;
  }

  // Get user balances for all sub-accounts or just one.
  // Returns an error string or an array of items of the form:
  //
  //    array($acct => array($t->ASSET =>
  //                         array($t->ASSET => $assetid,
  //                               $t->ASSETNAME => $assetname,
  //                               $t->AMOUNT => $amount,
  //                               $t->TIME => $time,
  //                               $t->FORMATTEDAMOUNT => $formattedamount),
  //                         ...),
  //          ...)
  //
  // where $assetid & $assetname describe the asset, $amount is the
  // amount, as an integer, $formattedamount is the amount as a
  // decimal number with the scale and precision applied, and $acct
  // is the name of the sub-account(s).
  //
  // The $acct arg is true for all sub-accounts, false for the
  // $t->MAIN sub-account only, or a string for that sub-account only.
  // The $assetid arg is false for all asset or an ID for that asset only.
  //
  // If you a specific $acct and a specific $assetid, the result
  // is an array mapping property names to values, not an array of arrays.
  function getbalance($acct=true, $assetid=false) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In getbalance(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getbalance_internal($acct, $assetid);
    $db->unlock($lock);

    return $res;
  }

  function compareaccts($a1, $a2) {
    $t = $this->t;

    if ($a1 == $t->MAIN) {
      if ($a2 == $t->MAIN) return 0;
      return -1;
    } elseif ($a2 == $t->MAIN) return 1;
    return strcmp(strtolower($a1), strtolower($a2));
  }

  function comparebalances($b1, $b2) {
    $t = $this->t;

    return $this->comparearrays($b1, $b2, array($t->ASSETNAME, $t->ASSET));
  }

  function getbalance_internal($inacct, $inassetid) {
    $t = $this->t;
    $db = $this->db;

    if (!$inacct) $inacct = $t->MAIN;
    if (is_string($inacct)) $accts = array($inacct);
    else {
      $accts = $db->contents($this->userbalancekey());
      usort($accts, array('client', 'compareaccts'));
    }

    $res = array();
    foreach ($accts as $acct) {
      if ($inassetid) $assetids = array($inassetid);
      else $assetids = $db->contents($this->userbalancekey($acct));
      $assets = array();
      foreach ($assetids as $assetid) {
        $amount = $this->userbalanceandtime($acct, $assetid, $time);
        if (!is_numeric($amount)) return "While gathering balances: $amount";
        $asset = $this->getasset($assetid);
        if (is_string($asset)) {
          $formattedamount = $amount;
          $assetname = "Unknown asset";
        } else {
          $formattedamount = $this->format_asset_value($amount, $asset);
          $assetname = $asset[$t->ASSETNAME];
        }
        $assets[$assetid] = array($t->ASSET => $assetid,
                                  $t->ASSETNAME => $assetname,
                                  $t->AMOUNT => $amount,
                                  $t->TIME => $time,
                                  $t->FORMATTEDAMOUNT => $formattedamount);
      }
      uasort($assets, array('client', 'comparebalances'));
      $res[$acct] = $assets;
    }
    if (is_string($inacct) && $inassetid) {
      if (count($res) == 0) $res = false;
      else $res = $res[$inacct][$inassetid];
    }
    return $res;
  }

  // Get the fraction balance for a particular assetid, or all assetids,
  // if $assetid is false. Result is:
  // array($assetid => array($t->AMOUNT => $amount,
  //                         $t->SCALE => $scale
  //                         $t->ASSETNAME => $assetname))
  // Amounts are raw, not scaled.
  // If an $assetid is specified, does not wrap the outer array around the result.
  function getfraction($assetid=false) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In getfraction(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getfraction_internal($assetid);
    $db->unlock($lock);

    return $res;
  }

  function getfraction_internal($inassetid) {
    $t = $this->t;
    $db = $this->db;

    if ($inassetid) $assetids = array($inassetid);
    else $assetids = $db->contents($this->userfractionkey());
    $res = array();
    foreach ($assetids as $assetid) {
      $key = $this->userfractionkey($assetid);
      $msg = $db->get($key);
      if ($msg) {
        $args = $this->unpack_bankmsg($msg, $t->ATFRACTION);
        if (is_string($args)) return "While unpacking fraction msg: $args";
        $args = $args[$t->MSG];
        $fraction = $args[$t->AMOUNT];
        $asset = $this->getasset($assetid);
        if (is_string($asset)) return "Error getting asset: $asset";
        $scale = $asset[$t->SCALE];
        $assetname = $asset[$t->ASSETNAME];
        $res[$assetid] = array($t->AMOUNT => $fraction,
                               $t->SCALE => $scale,
                               $t->ASSETNAME => $assetname);
      }      
    }
    if ($inassetid) return (@$res[$inassetid]);
    return $res;
  }

  // Get the storagefee balance for a particular assetid, or all assetids,
  // if $assetid is false. Result is:
  // array($assetid => array($t->ASSET => $assetid,
  //                         $t->ASSETNAME => $assetname
  //                         $t->AMOUNT => $amount,
  //                         $t->TIME => $time,
  //                         $t->FORMATTEDAMOUNT => $formattedamount)
  // If an $assetid is specified, does not wrap the outer array around the result.
  function getstoragefee($assetid=false) {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In getfraction(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getstoragefee_internal($assetid);
    $db->unlock($lock);

    return $res;
  }

  function getstoragefee_internal($inassetid) {
    $t = $this->t;
    $db = $this->db;
    $u = $this->u;

    $res = array();
    $key = $this->userstoragefeekey();
    if ($inassetid) $assetids = array($inassetid);
    else $assetids = $db->contents($key);
    foreach ($assetids as $assetid) {
      $msg = $db->get("$key/$assetid");
      $args = $this->unpack_bankmsg($msg, $t->STORAGEFEE);
      if (is_string($args)) return ("Error parsing storage fee: $args");
      $time = $args[$t->TIME];
      $assetid = $args[$t->ASSET];
      $amount = $args[$t->AMOUNT];
      $amt = $amount;
      $u->normalize_balance($amt, $fraction, 0);
      if ($amt) {
        $asset = $this->getasset($assetid);
        if (is_string($asset)) {
          $formattedamount = $amt;
          $assetname = "Unknown asset";
        } else {
          $formattedamount = $this->format_asset_value($amt, $asset);
          $assetname = $asset[$t->ASSETNAME];
        }
        $res[$assetid] = array($t->TIME => $time,
                               $t->ASSET => $assetid,
                               $t->ASSETNAME => $assetname,
                               $t->AMOUNT => $amount,
                               $t->TIME => $time,
                               $t->FORMATTEDAMOUNT => $formattedamount);
      }
    }
    uasort($res, array('client', 'comparebalances'));
    if ($inassetid) {
      if (count($res) == 0) $res = false;
      else $res = $res[$inassetid];
    }
    return $res;
  }

  // Enable or disable history
  function keephistory($enable) {
    $this->keephistory = $enable;
    return false;
  }

  // Initiate a spend
  // $toid is the id of the recipient of the spend
  //   May be $t->COUPON to generate a coupon
  //   In that case, the coupon itself can be fetched with getcoupon()
  // $assetid is the id of the asset to spend
  // $formattedamount is the formatted amount to spend
  // $acct is the source sub-account, default $t->MAIN
  // $acct can also be array($fromacct, $toacct), for a transfer.
  // In that case $toid should be the logged in ID.
  // Fees are always taken from $t->MAIN
  function spend($toid, $assetid, $formattedamount, $acct=false, $note=false) {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;

    if (!$this->current_bank()) return "In spend(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

    $parser->verifysigs(false);

    $lock = $db->lock($this->userreqkey());
    $res = $this->spend_internal($toid, $assetid, $formattedamount, $acct, $note);
    if ($res) {
      // Storage fee may have changed. Reload the asset.
      if ($this->reload_asset_p($assetid)) {
        $res = $this->spend_internal($toid, $assetid, $formattedamount, $acct, $note);
      }
    }
    $db->unlock($lock);

    $parser->verifysigs(true);

    if ($res) $this->forceinit();

    return $res;
  }

  function spend_internal($toid, $assetid, $formattedamount, $acct, $note) {
    $t = $this->t;
    $db = $this->db;
    $u = $this->u;

    $id = $this->id;
    $bankid = $this->bankid;
    $server = $this->server;
    $parser = $this->parser;

    if (!$acct) $acct = $t->MAIN;
    $toacct = $t->MAIN;
    if (!is_string($acct)) {
      $toacct = $acct[1];
      $acct = $acct[0];
      if (!(is_string($acct) && is_string($toacct))) {
        return "Bad accts: from: $acct, to: $to_acct";
      }
    }

    if ($id == $toid && $acct == $toacct) {
      return "Transfer from and to the same acct ($acct). Nothing to do.";
    }

    $amount = $this->unformat_asset_value($formattedamount, $assetid);
    if (bccomp($amount, 0) < 0) {
      $bal = $this->userbalance($acct, $assetid);
      if ($bal != $amount) {
        return "Negative spends must be for the whole issuer balance";
      }
    }

    $oldamount = $this->userbalanceandtime($acct, $assetid, $oldtime);
    if (!is_numeric($oldamount)) {
      return "Error getting balance for asset in acct $acct: $oldamount";
    }

    $time = $this->gettime();
    if (!$time) return "Unable to get timestamp for transaction from bank";

    $storagefee = 0;
    $digits = 0;
    $percent = $this->storageinfo($assetid, $fraction, $fractime);
    if ($percent) {
      $digits = $u->fraction_digits($percent);
      $fracfee = $u->storagefee($fraction, $fractime, $time, $percent, $digits);
      $storagefee = $u->storagefee($oldamount, $oldtime, $time, $percent, $digits);
      $storagefee = bcadd($storagefee, $fracfee, $digits);
      $baseoldamount = $oldamount;
      $oldamount = bcsub($oldamount, $storagefee, $digits);
      $u->normalize_balance($oldamount, $fraction, $digits);
    }

    $newamount = bcsub($oldamount, $amount);
    if (bccomp($oldamount, 0) >= 0 &&
        bccomp($newamount,  0) < 0) {
      if ($id == $toid && $percent && bccomp($amount, $baseoldamount) <= 0) {
        // User asked to transfer less than the whole amount, but the storage fee
        // put it over. Reduce amount to leave 0 in $acct
        $amount = $oldamount;
        $newamount = 0;
      } else return "Insufficient balance";
    }

    if ($id == $toid) {
      $oldtoamount = $this->userbalanceandtime($toacct, $assetid, $totime);
      if ($percent && $oldtoamount) {
        $tofee = $u->storagefee($oldtoamount, $totime, $time, $percent, $digits);
        $storagefee = bcadd($storagefee, $tofee, $digits);
        $oldtoamount = bcsub($oldtoamount, $tofee, $digits);
      }
      $newtoamount = bcadd($oldtoamount, $amount, $digits);
      if ($percent) $u->normalize_balance($newtoamount, $fraction, $digits);
      if (bccomp($oldtoamount, 0) < 0 &&
          bccomp($newtoamount, 0) >=0) {
        // This shouldn't be possible.
        // If it happens, it means the asset is out of balance.
        return "Asset out of balance";
      }
    }

    $tranfee = false;
    $tranfee_amt = false;
    $need_fee_balance = false;
    if ($id != $bankid) {
      $fees = $this->getfees();
      if (is_string($fees)) return $fees;
      $tranfee = $fees[$t->TRANFEE];
      $tranfee_asset = $tranfee[$t->ASSET];
      if ($id != $toid) $tranfee_amt = $tranfee[$t->AMOUNT];
      else $tranfee_amt = ($oldtoamount === false) ? 1 : 0;
      if ($tranfee_asset == $assetid && $t->MAIN == $acct) {
        $newamount = bcsub($newamount, $tranfee_amt);
        if (bccomp($oldamount, 0) >= 0 &&
            bccomp($newamount, 0) < 0) {
          return "Insufficient balance for transaction fee";
        }
      } elseif ($id == $toid && $tranfee_asset == $assetid && $t->MAIN = $toacct) {
        $newtoamount = bcsub($newtoamount, $tranfee_amt);
        if ($newtoamount == $oldtoamount) {
          "Transferring one token to a new acct is silly";
        }
        if (bccomp($oldtoamount, 0) >= 0 &&
            bccomp($newtoamount, 0) < 0) {
          return "Insufficient destination balance for transaction fee";
        }
      } else {
        $old_fee_balance = $this->userbalance($t->MAIN, $tranfee_asset);
        $fee_balance = bcsub($old_fee_balance, $tranfee_amt);
        $need_fee_balance = true; // $fee_balance could be 0
        if (bccomp($old_fee_balance, 0) >= 0 &&
            bccomp($fee_balance, 0) < 0) {
          return "Insufficient tokens for transaction fee";
        }
      }
    }

    if ($note) $spend = $this->custmsg($t->SPEND, $bankid, $time, $toid,
                                       $assetid, $amount, $note);
    else $spend = $this->custmsg($t->SPEND, $bankid, $time, $toid, $assetid, $amount);
    $feeandbal = '';
    $feebal = false;
    if ($tranfee_amt) {
      if ($id != $toid) {
        $feemsg = $this->custmsg
          ($t->TRANFEE, $bankid, $time, $tranfee_asset, $tranfee_amt);
        $feeandbal = $feemsg;
      }
      if ($need_fee_balance) {
        $feebal = $this->custmsg
          ($t->BALANCE, $bankid, $time, $tranfee_asset, $fee_balance);
        if ($feeandbal) $feeandbal .= '.';
        $feeandbal .= $feebal;
      }
    }      
    $balance = $this->custmsg
      ($t->BALANCE, $bankid, $time, $assetid, $newamount, $acct);
    $tobalance = false;
    if ($id == $toid) {
      $tobalance = $this->custmsg($t->BALANCE, $bankid, $time,
                                  $assetid, $newtoamount, $toacct);
    }
    $outboxhash = '';
    if ($id != $bankid && $id != $toid) {
      $outboxhash = $this->outboxhashmsg($time, $spend);
    }

    // Compute balancehash
    $balancehash = false;
    if ($id != $bankid) {
      if ($feebal) {
        if ($t->MAIN == $acct) {
          $acctbals = array($acct => array($assetid => $balance,
                                           $tranfee_asset => $feebal));
          if ($tobalance) $acctbals[$toacct] = array($assetid => $tobalance);
        } elseif ($id == $toid && $t->MAIN == $toacct) {
          $acctbals = array($acct => array($assetid => $balance),
                            $t->MAIN => array($assetid => $tobalance,
                                              $tranfee_asset => $feebal));
        } else {
          $acctbals = array($acct => array($assetid => $balance),
                            $t->MAIN => array($tranfee_asset => $feebal));
          if ($tobalance) $acctbals[$toacct] = array($assetid => $tobalance);
        }
      } else {
        $acctbals = array($acct => array($assetid => $balance));
        if ($tobalance) $acctbals[$toacct] = array($assetid => $tobalance);
      }
      $balancehash = $this->balancehashmsg($time, $acctbals);
    }

    // Prepare storage fee related message components
    if ($percent) {
      $storagefeemsg = $this->custmsg($t->STORAGEFEE, $bankid, $time, $assetid, $storagefee);
      $fracmsg = $this->custmsg($t->FRACTION, $bankid, $time, $assetid, $fraction);
    }

    // Send request to server, and get response
    $msg = $spend;
    if ($feeandbal) $msg.= ".$feeandbal";
    $msg .= ".$balance";
    if ($tobalance) $msg .= ".$tobalance";
    if ($outboxhash) $msg .= ".$outboxhash";
    if ($balancehash) $msg .= ".$balancehash";
    if ($percent) $msg .= ".$storagefeemsg.$fracmsg";
    $msg = $server->process($msg);

    $reqs = $parser->parse($msg);
    if (!$reqs) return "Can't parse bank return from spend: $msg";
    $spendargs = $this->match_bankreq($reqs[0], $t->ATSPEND);
    if (is_string($spendargs)) {
      $args = $this->match_bankreq($reqs[0]);
      if (is_string($args)) return $args;
      $request = $args[$t->REQUEST];
      if ($request = $t->FAILED) return "Spend request failed: " . $args[$t->ERRMSG];
      return "Spend request returned unknown message type: " . $request;
    }

    $msgs = array($spend => true,
                  $balance => true);
    if ($tobalance) $msgs[$tobalance] = true;
    if ($outboxhash) $msgs[$outboxhash] = true;
    if ($balancehash) $msgs[$balancehash] = true;
    if ($feeandbal) {
      if ($feemsg) $msgs[$feemsg] = true;
      if ($feebal) $msgs[$feebal] = true;
    }
    if ($percent) {
      $msgs[$storagefeemsg] = true;
      $msgs[$fracmsg] = true;
    }

    $coupon = false;
    foreach ($reqs as $req) {
      $msg = $parser->get_parsemsg($req);
      $args = $this->match_bankreq($req);
      if (is_string($args)) return "Error in spend response: $args";
      if ($args[$t->REQUEST] == $t->COUPONENVELOPE) {
        if ($coupon) return "Multiple coupons returned from server";
        $coupon = $msg;
        $encryptedcoupon = $args[$t->ENCRYPTEDCOUPON];
      } else {
        $m = $args[$t->MSG];
        if (!$m) return "No wrapped message in spend return: $msg";
        $m = trim($parser->get_parsemsg($m));
        if (!$msgs[$m]) return "Returned message wasn't sent: '$m'";
        if (is_string($msgs[$m])) return "Duplicate returned message: '$m'";
        $msgs[$m] = $msg;
      }
    }

    foreach ($msgs as $m => $msg) {
      if ($msg === true) return "Message not returned from spend: $m";
    }

    // All is well. Commit this baby.
    $db->put($this->userbalancekey($acct, $assetid), $msgs[$balance]);
    if ($tobalance) {
      $db->put($this->userbalancekey($toacct, $assetid), $msgs[$tobalance]);
    }
    if ($outboxhash) {
      $db->put($this->useroutboxhashkey(), $msgs[$outboxhash]);
    }
    if ($balancehash) {
      $db->put($this->userbalancehashkey(), $msgs[$balancehash]);
    }
    $spend = $msgs[$spend];
    if ($feeandbal) {
      $spend = "$spend." . $msgs[$feemsg];
      if ($feebal) {
        $db->put($this->userbalancekey($t->MAIN, $tranfee_asset), $msgs[$feebal]);
      }
    }
    if ($coupon) {
      $spend .= ".$coupon";
      $this->coupon = $encryptedcoupon;
    }
    if ($id != $toid && $id != $bankid) {
      $db->put($this->useroutboxkey($time), $spend);
    }
    $this->lastspendtime = $time;

    if ($percent) {
      $db->put($this->userfractionkey($assetid), $msgs[$fracmsg]);
    }

    if ($this->keephistory) {
      $key = $this->userhistorykey();
      $db->put("$key/$time", $spend);
    }

    return false;    
  }

  // Reload an asset from the server.
  // Return true if the storage percent changed.
  function reload_asset_p($assetid) {
    $t = $this->t;

    $asset = $this->getasset($assetid);
    if (is_string($asset)) return false;
    $percent = $asset[$t->PERCENT];
    $asset = $this->getasset($assetid, true);
    return ($percent != $asset[$t->PERCENT]);
  }

  function spendreject($time, $note=false) {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;

    if (!$this->current_bank()) return "In spendreject(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

    $parser->verifysigs(false);

    $lock = $db->lock($this->userreqkey());
    $res = $this->spendreject_internal($time, $note);
    $db->unlock($lock);

    $parser->verifysigs(true);

    if ($res) $this->forceinit();

    return $res;
  }

  function spendreject_internal($time, $note) {
    $t = $this->t;
    $db = $this->db;
    $u = $this->u;

    $bankid = $this->bankid;
    $id = $this->id;
    $db = $this->db;
    $server = $this->server;
    $parser = $this->parser;

    $msg = $this->useroutbox($time);
    if (!$msg) return "No outbox entry at time: $time";
    $reqs = $parser->parse($msg);
    if (!$reqs) return "In spendreject, parse error: " . $parser->errmsg;
    foreach ($reqs as $req) {
      $args = $this->match_bankreq($req);
      if (is_string($args)) return $args;
      if ($args[$t->REQUEST] == $t->COUPONENVELOPE) {
        $coupon = $args[$t->ENCRYPTEDCOUPON];
        if ($coupon) {
          $coupon = $this->ssl->privkey_decrypt($coupon, $this->privkey);
          return $this->redeem($coupon);
        }
      }
    }

    if ($note) {
      $msg = $this->custmsg($t->SPENDREJECT, $bankid, $time, $id, $note);
    } else {
      $msg = $this->custmsg($t->SPENDREJECT, $bankid, $time, $id);
    }

    $bankmsg = $server->process($msg);
    $args = $this->unpack_bankmsg($bankmsg, $t->INBOX);
    if (is_string($args)) return $args;

    $time = $args[$t->TIME];
    $args = $args[$t->MSG];
    $msg2 = $parser->get_parsemsg($args);
    if (trim($msg2) != trim($msg)) return "Bank return didn't wrap request";
    $key = $this->userinboxkey();
    $db->put("$key/$time", $bankmsg);

    return false;
  }

  function bccompnot($x, $y) {
    return bccomp($y, $x);
  }

  function gethistorytimes() {
    $t = $this->t;
    $db = $this->db;

    if (!$this->current_bank()) return "In gethistorytimes(): Bank not set";

    $key = $this->userhistorykey();
    $res = $db->contents($key);
    usort($res, array($this, 'bccompnot'));

    return $res;
  }

  // Get the history items for $time.
  // Return false if there is no corresponding item.
  // Otherwise, return an array of matched inner message arrays.
  // Return an error string if there is an error parsing or matching.
  function gethistoryitems($time) {
    $t = $this->t;
    $u = $this->u;
    $db = $this->db;
    $parser = $this->parser;

    if (!$this->current_bank()) return "In gethistoryitems(): Bank not set";

    $key = $this->userhistorykey();
    $msg = $db->get("$key/$time");
    if (!$msg) return false;

    $reqs = $parser->parse($msg);
    if (!$reqs) return "While parsing history item: " . $parser->errmsg;
    $res = array();
    foreach ($reqs as $req) {
      $args = $u->match_pattern($req);
      if (is_string($args)) return "While matching history item: " . $args;
      $inner = @$args[$t->MSG];
      if ($inner) {
        $atrequest = $args[$t->REQUEST];
        $args = $u->match_pattern($inner);
        if (is_string($args)) return "While matching inner history item: $args";
        $args[$t->ATREQUEST] = $atrequest;
      }
      $assetid = @$args[$t->ASSET];
      $amount = @$args[$t->AMOUNT];
      if ($assetid && !($amount === false)) {
        $asset = $this->getasset($assetid);
        if (!is_string($asset)) {
          $args[$t->ASSETNAME] = $asset[$t->ASSETNAME];
          $incnegs = false;
          $args[$t->FORMATTEDAMOUNT] =
            $this->format_asset_value($amount, $asset, $incnegs);
        } else {
          $args[$t->ASSETNAME] = $assetid;
          $args[$t->FORMATTEDAMOUNT] = $amount;
        }
      }
      $res[] = $args;
    }
    return $res;
  }

  // Remove a history item
  function removehistoryitem($time) {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;

    if (!$this->current_bank()) return "In removehistoryitem(): Bank not set";

    $key = $this->userhistorykey();
    $db->put("$key/$time", '');

    return false;
  }

  // Return the last coupon resulting from a spend.
  // Clear the coupon store, so you can only get the coupon once.
  function getcoupon() {
    $ssl = $this->ssl;
    $privkey = $this->privkey;

    $coupon = $this->coupon;
    $this->coupon = false;
    return $ssl->privkey_decrypt($coupon, $privkey);
  }

  // Get the inbox contents.
  // Returns an error string, or an array of inbox entries, indexed by
  // their timestamps:
  //
  //   array($time => array(array($t->REQUEST => $request
  //                              $t->ID => $fromid,
  //                              $t->TIME => $time,
  //                              $t->MSGTIME => $msgtime,
  //                              $t->ASSET => $assetid,
  //                              $t->ASSETNAME => $assetname,
  //                              $t->AMOUNT => $amount,
  //                              $t->FORMATTEDAMOUNT => $formattedamount,
  //                              $t->NOTE => $note),
  //                        ...,
  //                        $t->MSG => $msg),
  //          ...)
  //
  // Where $request is $t->SPEND, $t->SPENDACCEPT, or $t->SPENDREJECT,
  // $fromid is the ID of the sender of the inbox entry,
  // $time is the timestamp from the bank on the inbox entry,
  // $msgtime is the timestamp in the sender's message,
  // $assetid & $assetname describe the asset being transferred,
  // $amount is the amount of the asset being transferred, as an integer,
  // $formattedamount is the amount as a decimal number with the scale
  // and precision applied,
  // $note is the note that came from the sender,
  // $msg is the raw inbox message, included only if $includeraw
  // There will usually be two entries for a SPEND inbox entry, the SPEND
  // and the corresponding TRANFEE.
  // SPENDACCEPT and SPENDREJECT entries will be by themselves.
  function getinbox($includeraw=false) {
    $db = $this->db;

    if (!$this->current_bank()) return "In getinbox(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getinbox_internal();
    $db->unlock($lock);

    if ($res) $this->forceinit();

    return $res;
  }

  function getinbox_internal($includeraw=false) {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;

    $err = $this->sync_inbox();
    if ($err) return $err;

    $res = array();
    $key = $this->userinboxkey();
    $inbox = $db->contents($key);
    foreach ($inbox as $time) {
      $msg = $db->get("$key/$time");
      $reqs = $parser->parse($msg);
      if (!$reqs) return "Inbox parsing error: $reqs";
      $items = array();
      foreach ($reqs as $req) {
        $args = $this->match_bankreq($req);
        if (is_string($args)) return "Inbox unpack error: $args";
        if (@$args[$t->TIME] && $args[$t->TIME] != $time) {
          return "Inbox message timestamp mismatch";
        }
        $args = $args[$t->MSG];
        $request = $args[$t->REQUEST];
        $item = array();
        $item[$t->REQUEST] = $request;
        $item[$t->ID] = $args[$t->CUSTOMER];
        $item[$t->TIME] = $time;
        $item[$t->MSGTIME] = $args[$t->TIME];
        $item[$t->NOTE] = @$args[$t->NOTE];
        if ($request == $t->SPEND || $request == $t->TRANFEE) {
          $assetid = @$args[$t->ASSET];
          $amount = @$args[$t->AMOUNT];
          $asset = $this->getasset($assetid);
          $item[$t->ASSET] = $assetid;
          $item[$t->AMOUNT] = $amount;
          if (!is_string($asset)) {
            $item[$t->ASSETNAME] = $asset[$t->ASSETNAME];
            $incnegs = ($args[$t->CUSTOMER] != $this->bankid);
            $item[$t->FORMATTEDAMOUNT] =
              $this->format_asset_value($amount, $asset, $incnegs);
          }
        } elseif ($request == $t->SPENDACCEPT || $request == $t->SPENDREJECT) {
          // Pull in data from outbox to get amounts
        } else {
          return "Bad request in inbox: $request";
        }
        $items[] = $item;
      }
      if ($includeraw) $items[$t->MSG] = $msg;
      $res[$time] = $items;
    }

    return $res;
  }

  // Synchronize the current customer inbox with the current bank.
  // Return a string on error or false on success.
  // Assumes that there IS a current user and bank.
  // Does no database locking.
  function sync_inbox() {
    $t = $this->t;
    $db = $this->db;

    $bankid = $this->bankid;
    $parser = $this->parser;
    $server = $this->server;

    $req = $this->getreq();
    if (!$req) return "Couldn't get req for getinbox";
    $msg = $this->custmsg($t->GETINBOX, $bankid, $req);
    $bankmsg = $server->process($msg);
    
    $reqs = $parser->parse($bankmsg);
    if (!$reqs) return "While parsing getinbox return message: " . $parser->errmsg;
    $inbox = array();
    $times = array();
    $storagefees = array();
    $last_time = false;
    foreach ($reqs as $req) {
      $args = $this->match_bankreq($req);
      if (is_string($args)) return "While matching getinbox return: $args";
      $bankmsg = $parser->get_parsemsg($req);
      $request = $args[$t->REQUEST];
      if ($request == $t->ATGETINBOX) {
        $retmsg = $parser->get_parsemsg($args[$t->MSG]);
        if (trim($retmsg) != trim($msg)) return "getinbox return doesn't wrap message sent";
        $last_time = false;
      } elseif ($request == $t->INBOX) {
        $time = $args[$t->TIME];
        if (@$inbox[$time]) return "getinbox return included multiple entries for time: $time";
        $inbox[$time] = $bankmsg;
        $last_time = $time;
      } elseif ($request == $t->ATTRANFEE) {
        if (!$last_time) return "In getinbox return: @tranfee not after inbox";
        $inbox[$last_time] .= ".$bankmsg";
      } elseif ($request == $t->TIME) {
        $times[] = $args[$t->TIME];
      } elseif ($request == $t->STORAGEFEE) {
        $assetid = $args[$t->ASSET];
        $storagefees[$assetid] = $bankmsg;
      } elseif ($request != $t->COUPONNUMBERHASH) {
        return "Unknown request in getinbox return: $request";
      }
    }

    $key = $this->userinboxkey();
    $keys = $db->contents($key);
    foreach ($keys as $time) {
      $inmsg = @$inbox[$time];
      if ($inmsg) {
        $msg = $db->get("$key/$time");
        if ($msg != $inmsg) return "Inbox mismatch at time: $time";
        unset($inbox[$time]);
      } else {
        $db->put("$key/$time", '');
      }
    }
    foreach ($inbox as $time => $msg) {
      $db->put("$key/$time", $msg);
    }
    foreach ($storagefees as $assetid => $storagefee) {
      $key = $this->userstoragefeekey($assetid);
      $db->put($key, $storagefee);
    }
    if (count($times) > 0) {
      $db->put($this->usertimekey(), implode(',', $times));
    }
  }

  // Process the inbox contents.
  // $directions is an array of items of the form:
  //
  //  array($t->TIME => $time,
  //        $t->REQUEST => $request,
  //        $t->NOTE => $note,
  //        $t->ACCOUNT => $acct)
  //
  // where $time is a timestamp in the inbox,
  // $request is $t->SPENDACCEPT or $t->SPENDREJECT, or omitted for
  // processing an accept or reject from a former spend recipient,
  // $note is the note to go with the accept or reject, and
  // $acct is the account into which to transfer the funds (default: main).

  function processinbox($directions) {
    $db = $this->db;
    $parser = $this->parser;

    if (!$this->current_bank()) return "In processinbox(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

    $parser->verifysigs(false);

    $lock = $db->lock($this->userreqkey());
    $res = $this->processinbox_internal($directions, false);
    $db->unlock($lock);

    $parser->verifysigs(true);

    if ($res) $this->forceinit();

    return $res;
  }

  function processinbox_internal($directions, $recursive) {
    $t = $this->t;
    $db = $this->db;

    $bankid = $this->bankid;
    $server = $this->server;
    $parser = $this->parser;

    $inbox = $this->getinbox_internal($this->keephistory);
    $outbox = $this->getoutbox_internal($this->keephistory);
    $balance = $this->getbalance_internal(true, false);

    $timelist = '';
    $deltas = array(); // array($acct => array($asset => $delta, ...), ...)
    $outbox_deletions = array(); // array($timestamp, ...)

    $msg = '';
    $msgs = array();

    $history = '';
    $hist = '';

    $charges = array();

    foreach ($directions as $dir) {
      $time = $dir[$t->TIME];
      $request = @$dir[$t->REQUEST];
      $note = @$dir[$t->NOTE];
      $acct = @$dir[$t->ACCT];
      if (!$acct) $acct = $t->MAIN;

      if ($timelist) $timelist .= '|';
      $timelist .= $time;

      $ins = $inbox[$time];
      if (!$ins) return "No inbox entry for time: $time";

      $in = $ins[0];
      $fee = @$ins[1];        // will need generalization when I add multiple fees
      $inmsg = $ins[$t->MSG];

      $trans = $this->gettime();

      $inreq = $in[$t->REQUEST];
      if ($inreq == $t->SPEND) {
        $id = $in[$t->ID];
        $assetid = $in[$t->ASSET];
        $msgtime = $in[$t->MSGTIME];
        $amount = $in[$t->AMOUNT];
        if ($msg != '') $msg .= '.';
        if ($request == $t->SPENDACCEPT) {
          $this->do_storagefee($charges, $amount, $msgtime, $trans, $assetid);
          $deltas[$acct][$assetid] =
            bcadd(@$deltas[$acct][$assetid], $amount);
          $smsg = $this->custmsg($t->SPENDACCEPT, $bankid, $msgtime, $id, $note);
          $msgs[$smsg] = true;
          $msg .= $smsg;
          if ($inmsg) $hist .= ".$smsg.$inmsg";
        } elseif ($request == $t->SPENDREJECT) {
          if ($fee) {
            $deltas[$acct][$fee[$t->ASSET]] =
              bcadd(@$deltas[$acct][$fee[$t->ASSET]], $fee[$t->AMOUNT]);
          }
          $smsg = $this->custmsg($t->SPENDREJECT, $bankid, $msgtime, $id, $note);
          $msgs[$smsg] = true;
          $msg .= $smsg;
          if ($inmsg) $hist .= ".$smsg.$inmsg";
        } else {
          return "Illegal request for spend: $request";
        }
      } elseif ($inreq == $t->SPENDACCEPT || $inreq == $t->SPENDREJECT) {
        $msgtime = $in[$t->MSGTIME];
        $out = $outbox[$msgtime];
        if (!$out) return "Can't find outbox for $inreq at time $msgtime";
        $outbox_deletions[] = $msgtime;
        $outspend = $out[0];
        $outfee = $out[1];      // change when we have more than one fee
        if ($inreq == $t->SPENDREJECT) {
          // For rejected spends, we get our money back
          $assetid = $outspend[$t->ASSET];
          $amount = $outspend[$t->AMOUNT];
          $this->do_storagefee($charges, $amount, $msgtime, $trans, $assetid);
          $deltas[$acct][$assetid] = bcadd(@$deltas[$acct][$assetid], $amount);
          // And we have to pay for storage on the amount.
        } elseif ($outfee) {
          // For accepted spends, we get our tranfee back
          $deltas[$t->MAIN][$outfee[$t->ASSET]] =
            bcadd(@$deltas[$t->MAIN][$outfee[$t->ASSET]], $outfee[$t->AMOUNT]);
        }
        $outmsg = $out[$t->MSG];
        if ($outmsg) $hist .= ".$inmsg.$outmsg";
      } else {
        return "Unrecognized inbox request: $inreq";
      }
    }

    $pmsg = $this->custmsg($t->PROCESSINBOX, $bankid, $trans, $timelist);
    $msgs[$pmsg] = true;

    if ($msg) $msg = "$pmsg.$msg";
    else $msg = $pmsg;

    if ($this->keephistory) $history = "$pmsg$hist";

    $acctbals = array();

    // Compute fees for new balance files
    $fees = $this->getfees();
    if (is_string($fees)) return $fees;
    $tranfee = $fees[$t->TRANFEE];
    $feeasset = $tranfee[$t->ASSET];
    foreach ($deltas as $acct => $amounts) {
      foreach ($amounts as $asset => $amount) {
        $oldamount = @$balance[$acct][$asset][$t->AMOUNT];
        if (bccomp($oldamount, 0) != 0) {
          $oldtime = $balance[$acct][$asset][$t->TIME];
          $this->do_storagefee($charges, $oldamount, $oldtime, $trans, $asset);
          $balance[$acct][$asset][$t->AMOUNT] = $oldamount;
        }
        if ((!$oldamount) && !($oldamount==="0")) {
          $deltas[$t->MAIN][$feeasset] = bcsub($deltas[$t->MAIN][$feeasset], 1);
        }
      }
    }

    // Create balance, outboxhash, and balancehash messages
    foreach ($deltas as $acct => $amounts) {
      foreach ($amounts as $asset => $amount) {
        $oldamount = @$balance[$acct][$asset][$t->AMOUNT];
        $amount = bcadd($oldamount, $amount);
        $balmsg = $this->custmsg($t->BALANCE, $bankid, $trans, $asset, $amount, $acct);
        $msgs[$balmsg] = true;
        $acctbals[$acct][$asset] = $balmsg;
        $msg = $msg . ".$balmsg";
      }
    }

    if (count($outbox_deletions) > 0) {
      $outboxhash = $this->outboxhashmsg($trans, false, $outbox_deletions);
      $msgs[$outboxhash] = true;
      $msg = $msg . ".$outboxhash";
    } else $outboxhash = false;

    $balancehash = $this->balancehashmsg($trans, $acctbals);
    $msgs[$balancehash] = true;
    $msg = $msg . ".$balancehash";

    // Add storage and fraction messages
    $fracmsgs = array();
    foreach ($charges as $assetid => $assetinfo) {
      $percent = @$assetinfo['percent'];
      if ($percent) {
        $storagefee = $assetinfo['storagefee'];
        $fraction = $assetinfo['fraction'];
        $storagefeemsg = $this->custmsg($t->STORAGEFEE, $bankid, $trans, $assetid, $storagefee);
        $msgs[$storagefeemsg] = true;
        $fracmsg = $this->custmsg($t->FRACTION, $bankid, $trans, $assetid, $fraction);
        $msgs[$fracmsg] = true;
        $msg .= ".$storagefeemsg.$fracmsg";
        $fracmsgs[$assetid] = $fracmsg;
      }
    }

    // Send request to server
    $msg = $server->process($msg);

    // Validate return from server
    $reqs = $parser->parse($msg, true);
    if (!$reqs) return "Can't parse bank return from processinbox: $msg";
    $args = $this->match_bankreq($reqs[0], $t->ATPROCESSINBOX);
    if (is_string($args)) {
      $args = $this->match_bankreq($reqs[0]);
      if (is_string($args)) {
        if (!$recursive) {

          $parser->verifysigs(true);

          // Force reload of balances and outbox
          if ($err = $this->forceinit()) return $err;
          // Force reload of assets
          foreach ($charges as $assetid => $assetinfo) {
            $this->reload_asset_p($assetid);
          }

          $parser->verifysigs(false);

          return $this->processinbox_internal($directions, true);
        }
        return "Error from processinbox request: $args";
      }
      return "Processinbox request returned unknown message type: " . $request;
    }

    foreach ($reqs as $req) {
      $msg = $parser->get_parsemsg($req);
      $args = $this->match_bankreq($req);
      if (is_string($args)) return "Error in processinbox response: $args";
      $m = $args[$t->MSG];
      if (!$m) return "No wrapped message in processinbox return: $msg";
      $m = trim($parser->get_parsemsg($m));
      if (!$msgs[$m]) return "Returned message wasn't sent: '$m'";
      if (is_string($msgs[$m])) return "Duplicate returned message: '$m'";
      $msgs[$m] = $msg;
    }

    foreach ($msgs as $m => $msg) {
      if ($msg === true) return "Message not returned from processinbox: $m";
    }

    // Commit to database
    foreach ($acctbals as $acct => $bals) {
      foreach ($bals as $asset => $balmsg) {
        $db->put($this->userbalancekey($acct, $asset), $msgs[$balmsg]);
      }
    }

    foreach($fracmsgs as $assetid => $fracmsg) {
      $key = $this->userfractionkey($assetid);
      $db->put($key, $msgs[$fracmsg]);
    }

    if ($outboxhash) {
      foreach($outbox_deletions as $outbox_time) {
        $db->put($this->useroutboxkey($outbox_time), '');
      }
      $db->put($this->useroutboxhashkey(), $msgs[$outboxhash]);
    }

    $db->put($this->userbalancehashkey(), $msgs[$balancehash]);

    if ($history) {
      $key = $this->userhistorykey();
      $db->put("$key/$trans", $history);
    }

    return false;
  }

  // Tell server to move storage fees to inbox
  // You need to call getinbox to see the new data (via its call to sync_inbox).
  function storagefees() {
    $db = $this->db;
    $parser = $this->parser;

    if (!$this->current_bank()) return "In storagefees(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->storagefees_internal();
    $db->unlock($lock);

    return $res;
  }

  function storagefees_internal() {
    $t = $this->t;
    $bankid = $this->bankid;
    $server = $this->server;

    $req = $this->getreq();
    $msg = $this->custmsg($t->STORAGEFEES, $bankid, $req);

    $bankmsg = $server->process($msg);

    $args = $this->unpack_bankmsg($bankmsg);
    if (is_string($args)) return "Server error: $args";
    $request = $args[$t->REQUEST];
    if ($request != $t->ATSTORAGEFEES) return "Unknown response type: $request";

    return false;
  }

  // Add storage fee for $amount/$msgtime to $charges[$assetid]['storagefee']
  // and set $charges[$assetid]['fraction'] to the fractional balance.
  function do_storagefee(&$charges, &$amount, $msgtime, $time, $assetid) {
    $u = $this->u;

    if (bccomp($amount, 0) > 0) {
      $assetinfo = @$charges[$assetid];
      if (!$assetinfo) {
        $assetinfo = array();
        $percent = $this->storageinfo($assetid, $fraction, $fractime);
        if ($percent) {
          $digits = $u->fraction_digits($percent);
          if ($fraction) {
            $fracfee = $u->storagefee($fraction, $fractime, $time, $percent, $digits);
          } else $fracfee = 0;
          $assetinfo['percent'] = $percent;
          $assetinfo['fraction'] = bcsub($fraction, $fracfee, $digits);
          $assetinfo['storagefee'] = $fracfee;
          $assetinfo['digits'] = $digits;
        }
        $charges[$assetid] = $assetinfo;
      }
      $percent = @$assetinfo['percent'];
      if ($percent) {
        $digits = $assetinfo['digits'];
        $fee = $u->storagefee($amount, $msgtime, $time, $percent, $digits);
        $storagefee = bcadd($assetinfo['storagefee'], $fee, $digits);
        $assetinfo['storagefee'] = $storagefee;
        $amount = bcsub($amount, $fee, $digits);
        $fraction = $assetinfo['fraction'];
        $u->normalize_balance($amount, $fraction, $digits);
        $assetinfo['fraction'] = $fraction;
        $charges[$assetid] = $assetinfo;
      }
    }
  }

  // Get the outbox contents.
  // Returns an error string or the outbox contents as an array of
  // of the form:
  //
  //   array($time => array(array($t->REQUEST => $request,
  //                              $t->TIME => $time,
  //                              $t->ID => $recipientid,
  //                              $t->NOTE => $note,
  //                              $t->ASSET => $assetid,
  //                              $t->ASSETNAME => $assetname,
  //                              $t->AMOUNT => $amount,
  //                              $t->FORMATTEDAMOUNT => formattedamount),
  //                        ...),
  //         ...)
  //
  // $time is the timestamp of the outbox entry
  // $request is $t->SPEND, $t->TRANFEE, or $t->COUPONENVELOPE
  // $recipientid is the recipient for spend, or omitted for tranfee
  // $assetid is the ID of the asset transferred
  // $assetname is the name of $assetid
  // $amount is the amount transferred
  // $formattedamount is $amount formatted for output
  // $note is the transfer note, omitted for tranfee
  //
  // If $request is $t->COUPONENVELOPE, then $t->COUPON indexes the coupon itself,
  // as text, and the rest of the fields are unpopulated.
  function getoutbox() {
    $db = $this->db;

    if (!$this->current_bank()) return "In getoutbox(): Bank not set";
    if ($err = $this->initbankaccts()) return $err;

    $lock = $db->lock($this->userreqkey());
    $res = $this->getoutbox_internal();
    $db->unlock($lock);

    return $res;
  }

  function getoutbox_internal($includeraw=false) {
    $t = $this->t;
    $db = $this->db;
    $parser = $this->parser;

    $res = array();
    $key = $this->useroutboxkey();
    $outbox = $db->contents($key);
    foreach ($outbox as $time) {
      $msg = $db->get("$key/$time");
      $reqs = $parser->parse($msg, true);
      $items = array();
      if (!$reqs) return "In getoutbox, parse error: " . $parser->errmsg;
      foreach ($reqs as $req) {
        $args = $this->match_bankreq($req);
        if (is_string($args)) return $args;
        $request = $args[$t->REQUEST];
        if ($request != $t->COUPONENVELOPE) {
          $args = $args[$t->MSG];
          $request = $args[$t->REQUEST];
          if ($args[$t->TIME] != $time) {
            return "Outbox message timestamp mismatch";
          }
        }
        $item = array();
        $item[$t->REQUEST] = $request;
        $item[$t->TIME] = $time;
        $incnegs = false;
        if ($request == $t->SPEND) {
          $item[$t->ID] = $args[$t->ID];
          $item[$t->NOTE] = @$args[$t->NOTE];
          $incnegs = ($args[$t->ID] != $this->bankid);
        } elseif ($request == $t->TRANFEE) {
          // Nothing special to do here
        } elseif ($request == $t->COUPONENVELOPE) {
          $coupon = $args[$t->ENCRYPTEDCOUPON];
          if ($coupon) {
            $coupon = $this->ssl->privkey_decrypt($coupon, $this->privkey);
            $args = $this->unpack_bankmsg($coupon, $t->COUPON);
            if (is_string($args)) $coupon = "Coupon malformed: $coupon";
            else {
              $url = $args[$t->BANKURL];
              $coupon_number = $args[$t->COUPON];
              $coupon = "[$url, $coupon_number]";
            }
            $item[$t->COUPON] = $coupon;
          }
        } else {
          return "Bad request in outbox: $request";
        }
        $assetid = $args[$t->ASSET];
        $amount = $args[$t->AMOUNT];
        if ($assetid) {
          $asset = $this->getasset($assetid);
          $item[$t->ASSET] = $assetid;
          $item[$t->AMOUNT] = $amount;
          if (!is_string($asset)) {
            $item[$t->ASSETNAME] = $asset[$t->ASSETNAME];
            $item[$t->FORMATTEDAMOUNT] =
              $this->format_asset_value($amount, $asset, $incnegs);
          }
        }
        $items[] = $item;
        if ($includeraw) $items[$t->MSG] = $msg;
      }
      $res[$time] = $items;
    }

    uksort($res, 'bccomp');
    return $res;
  }

  // Redeem a coupon
  // If successful, add an inbox entry for the coupon spend and return false.
  // If fails, return error message.
  // Needs an option to process the coupon, intead of just adding it to
  // the inbox.
  function redeem($coupon) {
    $t = $this->t;
    $bankid = $this->bankid;
    $ssl = $this->ssl;

    $pubkey = $this->pubkeydb->get($bankid);
    if (!$pubkey) return "Can't get bank public key";
    
    $coupon = $ssl->pubkey_encrypt($coupon, $pubkey);
    $msg = $this->sendmsg($t->COUPONENVELOPE, $bankid, $coupon);
    $args = $this->unpack_bankmsg($msg, $t->ATCOUPONENVELOPE);
    if (is_string($args)) return "Redeem: $args";
    return false;
  }

  // End of API methods

  // For utility->bankgetter
  function bankid() {
    return $this->bankid;
  }

  function passphrasehash($passphrase) {
    return sha1(trim($passphrase));
  }

  // Create a signed customer message.
  // Takes an arbitrary number of args.
  function custmsg() {
    $id = $this->id;
    $u = $this->u;
    $ssl = $this->ssl;
    $privkey = $this->privkey;

    $args = func_get_args();
    $args = array_merge(array($id), $args);
    $msg = $u->makemsg($args);
    $sig = $ssl->sign($msg, $privkey);
    return trim("$msg:\n$sig");
  }

  // Send a customer message to the server.
  // Takes an arbitrary number of args.
  function sendmsg() {
    $server = $this->server;

    $req = func_get_args();
    $msg = call_user_func_array(array($this, 'custmsg'), $req);
    return $server->process($msg);
  }

  // Unpack a bank message
  // Return a string if parse error or fail from bank
  // This is called via the $unpacker arg to utility->dirhash & balancehash
  function unpack_bankmsg($msg, $request=false, $bankid=false) {
    $parser = $this->parser;

    $reqs = $parser->parse($msg);
    if (!$reqs) {
      return "In unpack_bankmsg, parse error: " . $parser->errmsg;
    }

    $req = $reqs[0];
    $args = $this->match_bankreq($req, $request, $bankid);
    if (!is_string($args)) {
      $args[$this->unpack_reqs_key] = $reqs; // save parse results
    }
    return $args;
  }

  // Unpack a bank message that has already been parsed
  function match_bankreq($req, $request=false, $bankid=false) {
    $t = $this->t;
    $u = $this->u;
    if (!$bankid) $bankid = $this->bankid;

    $args = $u->match_pattern($req, $bankid);
    if (is_string($args)) return "While matching: $args";
    if ($args[$t->CUSTOMER] != $bankid) return "Return message not from bank";
    if ($args[$t->REQUEST] == $t->FAILED) return $args[$t->ERRMSG];
    if ($request && $args[$t->REQUEST] != $request) {
      return "Wrong return type from bank; sb: $request, was: " . $args[$t->REQUEST];
    }
    if (@$args[$t->MSG]) {
      $msgargs = $u->match_pattern($args[$t->MSG]);
      if (is_string($msgargs)) return "While matching bank-wrapped msg: $msgargs";
      if (array_key_exists($t->BANKID, $msgargs) &&
          $msgargs[$t->BANKID] != $bankid) {
        return "While matching bank-wrapped msg: bankid mismatch";
      }
      $args[$t->MSG] = $msgargs;
    }
    return $args;
  }

  // Get the values necessary to compute the storage fee.
  // Inputs:
  // $id - the user ID
  // $assetid - the asset ID
  // Return value: storage fee $percent
  // On output (set only if $percent != 0):
  // $fraction - the fraction balance for $id/$assetid
  // $fractime - the time of the fraction
  function storageinfo($assetid, &$fraction, &$fractime) {
    $t = $this->t;
    $u = $this->u;
    $parser = $this->parser;
    $db = $this->db;

    $asset = $this->getasset($assetid);
    if (!$asset) return 0;
    $issuer = $asset[$t->ISSUER];
    $percent = $fraction = $fractime = 0;
    if ($issuer == $this->id) return;

    $percent = $asset[$t->PERCENT];
        
    if (!$percent) return;

    $key = $this->userfractionkey($assetid);
    $msg = $db->get($key);
    if ($msg) {
      $args = $this->unpack_bankmsg($msg, $t->ATFRACTION);
      if (!is_string($args)) {
        $args = $args[$t->MSG];
        $fraction = $args[$t->AMOUNT];
        $fractime = $args[$t->TIME];
      }
    }

    return $percent;
  }

  function pubkey($id) {
    $db = $this->pubkeydb;
    return $db->get($id);
  }

  function pubkeykey($id) {
    $t = $this->t;
    return $t->PUBKEY . "/$id";
  }

  function bankkey($prop=false, $bankid=false) {
    $t = $this->t;
    if (!$bankid) $bankid = $this->bankid;

    $key = $t->BANK . "/$bankid";
    return $prop ? "$key/$prop" : $key;
  }

  function bankprop($prop, $bankid=false) {
    $db = $this->db;

    return $db->get($this->bankkey($prop, $bankid));
  }

  function assetkey($assetid=false) {
    $t = $this->t;

    $key = $this->bankkey($t->ASSET);
    if ($assetid) $key .= "/$assetid";
    return $key;
  }

  function assetprop($assetid) {
    $db = $this->db;

    return $db->get($this->assetkey($assetid));
  }

  function tranfeekey() {
    $t = $this->t;

    return $this->bankkey($t->TRANFEE);
  }

  function tranfee() {
    $db = $this->db;

    return $db->get($this->tranfeekey());
  }

  function regfeekey() {
    $t = $this->t;

    return $this->bankkey($t->REGFEE);
  }

  function regfee() {
    $db = $this->db;

    return $db->get($this->regfeekey());
  }

  function userbankkey($prop=false, $bankid=false) {
    $t = $this->t;
    $id = $this->id;
    if (!$bankid) $bankid = $this->bankid;

    $key = $t->ACCOUNT . "/$id/" . $t->BANK . "/$bankid";
    return $prop ? "$key/$prop" : $key;
  }

  function userbankprop($prop, $bankid=false) {
    $db = $this->db;

    return $db->get($this->userbankkey($prop, $bankid));
  }

  function userreqkey($bankid=false) {
    $t = $this->t;

    return $this->userbankkey($t->REQ, $bankid);
  }

  function userreq($bankid=false) {
    $db = $this->db;

    return $db->get($this->userreqkey($bankid));
  }

  function usertimekey() {
    $t = $this->t;

    return $this->userbankkey($t->TIME);
  }

  // Called via $unpacker->balancekey() in utility->balancehash()
  function balancekey($id) {
    if ($id != $this->id) die("ID mismatch in client->balancekey()");
    return $this->userbalancekey();
  }

  function userfractionkey($assetid=false) {
    $key = $this->userbankkey($this->t->FRACTION);
    if ($assetid) $key .= "/$assetid";
    return $key;
  }

  function userstoragefeekey($assetid=false) {
    $res = $this->userbankkey($this->t->STORAGEFEE);
    if ($assetid) $res .= "/$assetid";
    return $res;
  }

  function userbalancekey($acct=false, $assetid=false) {
    $t = $this->t;

    $key = $this->userbankkey($t->BALANCE);
    if ($acct) {
      $key .= "/$acct";
      if ($assetid) $key .= "/$assetid";
    }
    return $key;
  }

  function userbalance($acct, $assetid) {
    return $this->userbalanceandtime($acct, $assetid, $time);
  }

  function userbalanceandtime($acct, $assetid, &$time) {
    $db = $this->db;
    $t = $this->t;

    $msg = $db->get($this->userbalancekey($acct, $assetid));
    if ($msg) {
      $args = $this->unpack_bankmsg($msg, $t->ATBALANCE);
      if (is_string($args)) return $args;
      $args = $args[$t->MSG];
      $time = $args[$t->TIME];
      return $args[$t->AMOUNT];
    }
    return false;
  }

  function useroutboxkey($time=false) {
    $t = $this->t;

    $key = $this->userbankkey($t->OUTBOX);
    if ($time) $key .= "/$time";
    return $key;
  }

  function useroutbox($time) {
    $db = $this->db;

    return $db->get($this->useroutboxkey($time));
  }

  function useroutboxhashkey() {
    $t = $this->t;

    return $this->userbankkey($t->OUTBOXHASH);
  }

  function useroutboxhash() {
    $db = $this->db;

    return $db->get($this->useroutboxhashkey());
  }

  function userbalancehashkey() {
    $t = $this->t;

    return $this->userbankkey($t->BALANCEHASH);
  }

  function userbalancehash() {
    $db = $this->db;

    return $db->get($this->userbalancehashkey());
  }

  function userinboxkey() {
    $db = $this->db;
    $t = $this->t;

    return $this->userbankkey($t->INBOX);
  }

  function contactkey($otherid=false, $prop=false) {
    $t = $this->t;

    $res = $this->userbankkey($t->CONTACT);
    if ($otherid) {
      $res .= "/$otherid";
      if ($prop) $res .= "/$prop";
    }
    return $res;
  }

  function contactprop($otherid, $prop) {
    $db = $this->db;

    $key = $this->contactkey($otherid, $prop);
    return $db->get($this->contactkey($otherid, $prop));
  }

  function userhistorykey() {
    $t = $this->t;

    return $this->userbankkey($t->HISTORY);
  }

  // format an asset value from the asset ID or $this->getasset($assetid)
  function format_asset_value($value, $assetid, $incnegs=true) {
    $t = $this->t;

    if (is_string($assetid)) $asset = $this->getasset($assetid);
    else $asset = $assetid;
    if (is_string($asset)) return $value;
    return $this->format_value($value, $asset[$t->SCALE], $asset[$t->PRECISION], $incnegs);
  }

  // Unformat an asset value from the asset ID or $this->getasset($assetid)
  function unformat_asset_value($formattedvalue, $assetid) {
    $t = $this->t;

    if (is_string($assetid)) $asset = $this->getasset($assetid);
    else $asset = $assetid;
    if (is_string($asset)) return $value;
    return $this->unformat_value($formattedvalue, $asset[$t->SCALE]);
  }

  // format an asset value for user printing
  function format_value($value, $scale, $precision, $incnegs=true) {
    $sign = 1;
    if ($incnegs && bccomp($value, 0) < 0) {
      $value = bcadd($value, 1);
      $sign = -1;
    }
    if ($scale == 0 && $precision == 0) $res = $value;
    else {
      if ($scale > 0) {
        $res = bcdiv($value, bcpow(10, $scale), $scale);
      }
      $dotpos = strpos($res, '.');
      if ($dotpos === false) {
        if ($precision != 0) {
          $res .= '.' . str_repeat('0', $precision);
        }
      } else {
        // Remove trailing zeroes
        for ($endpos = strlen($res)-1; $endpos>$dotpos; $endpos--) {
          if ($res[$endpos] != '0') break;
        }
        $zeroes = $precision - ($endpos - $dotpos);
        $zerostr = ($zeroes >= 0) ? str_repeat('0', $zeroes) : '';
        $res = substr($res, 0, $endpos+1) . $zerostr;
      }
    }
    if ($value == 0 && $sign < 0) $res = "-$res";

    // Insert commas
    $start = 0;
    if (substr($res, 0, 1) == '-') $start++;
    $dotpos = strpos($res, '.');
    if ($dotpos === false) $dotpos = strlen($res);
    $len = $dotpos - $start;
    while ($len > 3) {
      $res = substr($res, 0, $len+$start-3) . ',' . substr($res, $len+$start-3);
      $len -= 3;
    }

    return $res;
  }

  function unformat_value($formattedvalue, $scale) {
    if ($scale == 0) $value = $formattedvalue;
    else $value = bcmul($formattedvalue, bcpow(10, $scale), 0);
    if ((bccomp($value, 0) < 0) ||
        ($value == 0 && substr($formattedvalue, 0, 1) == '-')) {
      $value = bcsub($value, 1);
    }
    return $value;
  }

  // Send a t->ID command to the server, if there is one.
  // Parse out the pubkey, cache it in the database, and return it.
  // Return the empty string if there is no server or it doesn't know
  // the id.
  // If $wholemsg is true, return the $args for the whole $t->REGISTER
  // message, intead of just the pubkey, and return an error message,
  // instead of the empty string, if there's a problem.
  function get_pubkey_from_server($id, $wholemsg=false) {
    $t = $this->t;
    $db = $this->db;
    $bankid = $this->bankid;

    if (!$this->current_bank()) {
      return $wholemsg ? 'In get_pubkey_from_server: Bank not set' : '';
    }

    $msg = $this->sendmsg($t->ID, $bankid, $id);
    $args = $this->unpack_bankmsg($msg, $t->ATREGISTER);
    if (is_string($args)) return $wholemsg ? $args : '';
    $args = $args[$t->MSG];
    $pubkey = $args[$t->PUBKEY];
    $pubkeykey = $this->pubkeykey($id);
    if ($pubkey) {
      if (!$db->get($pubkeykey)) $db->put($pubkeykey, $pubkey);
      if ($wholemsg) return $args;
      return $pubkey;
    }
    return $wholemsg ? "Can't find pubkey on server" : '';
  }

  // Get a new request
  function getreq() {
    $t = $this->t;
    $db = $this->db;

    $key = $this->userreqkey();
    $lock = $db->lock($key);
    $reqnum = $this->getreq_internal($key);
    $db->unlock($lock);

    return $reqnum;
  }

  function getreq_internal($key) {
    $t = $this->t;
    $db = $this->db;

    $reqnum = bcadd($db->get($key), 1);
    $db->put($key, $reqnum);
    return $reqnum;
  }

  // Get a timestamp from the server
  function gettime($forcenew=false) {
    $t = $this->t;
    $db = $this->db;
    $bankid = $this->bankid;

    $key = $this->usertimekey();
    if ($forcenew) $db->put($key, '');
    else {
      $times = $db->get($key);
      if ($times) {
        $times = explode(',', $times);
        $time = $times[0];
        $db->put($key, $times[1]);
        return $time;
      }
    }

    $req = $this->getreq();
    if (!$req) return false;
    $msg = $this->sendmsg($t->GETTIME, $bankid, $req);
    $args = $this->unpack_bankmsg($msg, $t->TIME);
    if (is_string($args)) return false;
    return $args[$t->TIME];
  }

  // Check once per instance that the local idea of the reqnum matches
  // that at the bank.
  // If it doesn't, clear the account information, so that initbankaccts()
  // will reinitialize.
  // Eventually, we want to compare to see if we can catch a bank error.
  function syncreq() {
    $db = $this->db;
    $t = $this->t;

    $key = $this->userbankkey($t->REQ);
    $reqnum = $db->get($key);
    if ($reqnum == -1) $this->syncedreq = true;
    if (!$this->syncedreq) {
      $bankid = $this->bankid;
      $msg = $this->sendmsg($t->GETREQ, $bankid);
      $args = $this->unpack_bankmsg($msg, $t->REQ);
      if (is_string($args)) return false;
      $newreqnum = $args[$t->REQ];
      if ($reqnum != $newreqnum) {
        $reqnum = -1;
        $balkey = $this->userbalancekey();
        $accts = $db->contents($balkey);
        foreach ($accts as $acct) {
          $acctkey = "$balkey/$acct";
          $assetids = $db->contents($acctkey);
          foreach ($assetids as $assetid) {
            $key = "$acctkey/$assetid";
            $db->put($key, '');
          }
        }
        $frackey = $this->userfractionkey();
        $assetids = $db->contents($frackey);
        foreach ($assetids as $assetid) {
          $key = "$frackey/$assetid";
          $db->put($key, '');
        }
        $outboxkey = $this->useroutboxkey();
        $outtimes = $db->contents($outboxkey);
        foreach ($outtimes as $outtime) {
          $key = "$outboxkey/$outtime";
          $db->put($key, '');
        }
        $db->put($this->userbalancehashkey(), '');
        $db->put($this->useroutboxhashkey(), '');
      }
      $this->syncedreq = true;
    }
    return $reqnum;
  }

  // Force a reinit of the client database for the current user
  function forceinit() {
    $db = $this->db;

    $db->put($this->userreqkey(), 0);
    $this->syncedreq = false;
    return $this->initbankaccts();
  }

  // If we haven't yet downloaded accounts from the bank, do so now.
  // This is how a new client instance gets initialized from an existing
  // bank instance.
  // Return false on success or error string.
  function initbankaccts() {
    $t = $this->t;
    $db = $this->db;
    $id = $this->id;
    $bankid = $this->bankid;
    $parser = $this->parser;

    $reqnum = $this->syncreq();

    if ($reqnum == -1) {

      // Get $t->REQ
      $msg = $this->sendmsg($t->GETREQ, $bankid);
      $args = $this->unpack_bankmsg($msg, $t->REQ);
      if (is_string($args)) return "While getting req to initialize accounts: $args";
      $reqnum = bcadd($args[$t->REQ], 1);

      // Get account balances
      $msg = $this->sendmsg($t->GETBALANCE, $bankid, $reqnum);
      $reqs = $parser->parse($msg, true);
      if (!$reqs) {
        if ($parser->errmsg) {
          return "While parsing getbalance: " . $parser->errmsg;
        }
        $reqs = array();
      }
      $balances = array();
      $fractions = array();
      $balancehash = false;
      foreach ($reqs as $req) {
        $args = $this->match_bankreq($req);
        if (is_string($args)) return "While matching getbalance: $args";
        $request = $args[$t->REQUEST];
        $msgargs = $args[$t->MSG];
        $customer = $msgargs[$t->CUSTOMER];
        if ($msgargs && $customer != $id) {
          return "Bank wrapped somebody else's ($customer) message: $msg";
        }
        if ($request == $t->ATBALANCE) {
          if ($msgargs[$t->REQUEST] != $t->BALANCE) {
            return "Bank wrapped a non-balance request with @balance";
          }
          $assetid = $msgargs[$t->ASSET];
          if (!$assetid) return "Bank wrapped balance missing asset ID";
          $acct = @$msgargs[$t->ACCT];
          if (!$acct) $acct = $t->MAIN;
          $balances[$acct][$assetid] = $parser->get_parsemsg($req);
        } else if ($request == $t->ATBALANCEHASH) {
          $balancehash = $parser->get_parsemsg($req);
        } else if ($request == $t->ATFRACTION) {
          if ($msgargs[$t->REQUEST] != $t->FRACTION) {
            return "Bank wrapped a non-fraction request with @fraction";
          }
          $assetid = $msgargs[$t->ASSET];
          if (!$assetid) return "Bank wrapped fraction missing asset ID";
          $fraction = $parser->get_parsemsg($req);
          $fractions[$assetid] = $fraction;
        }
      }

      // Get outbox
      $reqnum = bcadd($reqnum, 1);
      $msg = $this->sendmsg($t->GETOUTBOX, $bankid, $reqnum);
      $reqs = $parser->parse($msg, true);
      if (!$reqs) return "While parsing getoutbox: " . $parser->errmsg;
      $outbox = array();
      $outboxhash = '';
      $outboxtime = false;
      foreach ($reqs as $req) {
        $args = $this->match_bankreq($req);
        if (is_string($args)) return "While matching getoutbox: $args";
        $request = $args[$t->REQUEST];
        $msgargs = @$args[$t->MSG];
        $customer = $msgargs[$t->CUSTOMER];
        if ($msgargs && $msgargs[$t->CUSTOMER] != $id) {
          return "Bank wrapped somebody else's ($customer) message: $msg";
        }
        if ($request == $t->ATGETOUTBOX) {
          $outboxtime = false;
        } elseif ($request == $t->ATSPEND) {
          if ($msgargs[$t->REQUEST] != $t->SPEND) {
            return "Bank wrapped a non-spend request with @spend";
          }
          $time = $msgargs[$t->TIME];
          $outbox_time = $time;
          $outbox[$time] = $parser->get_parsemsg($req);
        } elseif ($request == $t->ATTRANFEE) {
          if ($msgargs[$t->REQUEST] != $t->TRANFEE) {
            return "Bank wrapped a non-tranfee request with @tranfee";
          }
          $time = $msgargs[$t->TIME];
          $msg = $outbox[$time];
          if (!$msg) return "No spend message for time: $time";
          $msg = "$msg." . $parser->get_parsemsg($req);
          $outbox[$time] = $msg;
        } elseif ($request == $t->ATOUTBOXHASH) {
          if ($msgargs[$t->REQUEST] != $t->OUTBOXHASH) {
            return "Bank wrapped a non-outbox request with @outboxhash";
          }
          $outboxhash = $parser->get_parsemsg($req);
        } elseif ($request == $t->COUPONENVELOPE) {
          if (!$outbox_time) return "Got a coupon envelope with no outboxtime";
          $msg = $outbox[$outbox_time];
          if (!$msg) return "No spend message for coupon envelope";
          $msg = "$msg." . $parser->get_parsemsg($req);
          $outbox[$outbox_time] = $msg;
          $outbox_time = false;
        } else {
          return "While processing getoutbox: bad request: $request";
        }
      }

      if ($id != $bankid && count($outbox) > 0 && !$outboxhash) {
        return "While procesing getoutbox: outbox items but no outboxhash";
      }

      // All is well. Write the data
      foreach ($balances as $acct => $assets) {
        foreach ($assets as $assetid => $msg) {
          $db->put($this->userbalancekey($acct, $assetid), $msg);
        }
      }

      foreach ($fractions as $assetid => $fraction) {
        $key = $this->userfractionkey($assetid);
        $db->put($key, $fraction);
      }

      if ($balancehash) {
        $db->put($this->userbalancehashkey(), $balancehash);
      }

      foreach ($outbox as $time => $msg) {
        $db->put($this->useroutboxkey($time), $msg);
      }
      $db->put($this->useroutboxhashkey(), $outboxhash);
      $db->put($this->userreqkey(), $reqnum);
    }
    return false;
  }

  function balancehashmsg($time, $acctbals) {
    $u = $this->u;
    $t = $this->t;
    $db = $this->db;
    $bankid = $this->bankid;

    $hasharray = $u->balancehash($db, $this->id, $this, $acctbals);
    $hash = $hasharray[$t->HASH];
    $hashcnt = $hasharray[$t->COUNT];
    $balancehash = $this->custmsg($t->BALANCEHASH, $bankid, $time, $hashcnt, $hash);

    return $balancehash;
  }


  function outboxhashmsg($transtime, $newitem=false, $removed_times=false) {
    $db = $this->db;
    $u = $this->u;
    $t = $this->t;

    $hasharray = $u->dirhash
      ($db, $this->useroutboxkey(), $this, $newitem, $removed_times);
    $hash = $hasharray[$t->HASH];
    $hashcnt = $hasharray[$t->COUNT];
    return $this->custmsg($this->t->OUTBOXHASH,
                          $this->bankid,
                          $transtime,
                          $hashcnt,
                          $hash);
  }

  // Web client session support

  // Return a new, random, session ID
  function newsessionid() {
    $random = $this->random;
    if (!$random) {
      require_once "LoomRandom.php";
      $random = new LoomRandom();
      $this->random = $random;
    }
    $res = bin2hex($random->urandom_bytes(20));
    if (strlen($res) < 40) $res = str_repeat("0", 40 - strlen($res)) . $res;
    return $res;
  }

  // xor hashed copies of $key with $string and return the result.
  // This is a really simple encryption that only really works if
  // $key is known to be random, e.g. the output of newsessionid().
  function xorcrypt($key, $string) {
    $key = @pack("H*", sha1($key));
    $idx = 0;
    $keylen = strlen($key);
    $len = strlen($string);
    $res = '';
    for ($i=0; $i<$len; $i++) {
      $res .= chr(ord(substr($key, $idx, $idx+1)) ^ ord(substr($string, $i, $i+1)));
      $idx++;
      if ($idx >= $keylen) {
        $idx = 0;
        $key = @pack("H*", sha1($key));
        $keylen = strlen($key);
      }
    }
    return $res;
  }

  // Return the database key for the user's session hash.
  function usersessionkey() {
    $t = $this->t;
    $id = $this->id;

    return $t->ACCOUNT . "/$id/" . $t->SESSION;
  }

  // Return the user's session hash.
  function usersessionhash() {
    $db = $this->db;

    return $db->get($this->usersessionkey());
  }

  // Return the database key for a session hash
  function sessionkey($sessionhash) {
    $t = $this->t;

    return $t->SESSION . "/$sessionhash";
  }

  // Return the passphrase corresponding to a session id
  function sessionpassphrase($sessionid) {
    $db = $this->db;

    $passcrypt = $db->get($this->sessionkey(sha1($sessionid)));
    $passphrase = $this->xorcrypt($sessionid, $passcrypt);
    if (!$passphrase) return "No passphrase for session";
    return $passphrase;
  }

  // Create a new user session, encoding $passphrase with a new session id.
  // Return the new session id.
  // If the user already has a session stored with another session id,
  // remove that one first.
  function makesession($passphrase) {
    $db = $this->db;

    $sessionid = $this->newsessionid();
    $passcrypt = $this->xorcrypt($sessionid, $passphrase);
    $usersessionkey = $this->usersessionkey();
    $lock = $db->lock($usersessionkey);
    $oldhash = $db->get($usersessionkey);
    if ($oldhash) {
      $db->put($this->sessionkey($oldhash), '');
    }
    $newhash = sha1($sessionid);
    $db->put($this->sessionkey($newhash), $passcrypt);
    $db->put($usersessionkey, $newhash);
    $db->unlock($lock);
    return $sessionid;
  }

  // Remove the current user's session
  function removesession() {
    $db = $this->db;

    $usersessionkey = $this->usersessionkey();
    $lock = $db->lock($usersessionkey);
    $oldhash = $db->get($usersessionkey);
    if ($oldhash) {
      $db->put($this->sessionkey($oldhash), '');
      $db->put($usersessionkey, '');
    }
    $db->unlock($lock);
  }

  // Preferences
  function userpreferencekey($pref) {
    $t = $this->t;
    $id = $this->id;

    return $t->ACCOUNT . "/$id/" . $t->PREFERENCE . "/$pref";
  }

  // Get or set a user preference.
  // Include the $value to set.
  function userpreference($pref, $value=true) {
    $db = $this->db;

    $key = $this->userpreferencekey($pref);
    if ($value === true) $value = $db->get($key);
    else $db->put($key, $value);
    return $value;
  }

  // Account creation tokens
  // A kluge to keep spammers out of my web client

  function tokenkey($token=false) {
    $t = $this->t;
    
    $key = $t->TOKEN;
    if ($token) $key .= "/$token";
    return $key;
  }

  function token($token, $value=false) {
    $db = $this->db;

    $key = $this->tokenkey($token);
    if ($value === false) return $db->get($key);
    else {
      $db->put($key, $value);
      return $value;
    }
  }

  // Returns array($tok => $value, ...)
  function gettokens() {
    $db = $this->db;

    $tokens = $db->contents($this->tokenkey());
    $res = array();
    foreach ($tokens as $tok) {
      $res[$tok] = $db->get($this->tokenkey($tok));
    }
    return $res;
  }

  // Add a string to the debug output.
  // Does NOT add a newline.
  // Use var_export($val, true) to dump arrays
  function debugmsg($x) {
    $showfun = $this->showprocess;
    if ($showfun) @$showfun($x);
  }

  function server_times() {
    return $this->server_times;
  }

  function accumulate_server_times($times) {
    $this->server_times = $this->accumulate_times($times, $this->server_times);
  }

  function accumulate_times($from, $into) {
    foreach ($from as $name => $stats) {
      $into[$name]['cnt'] = @$into[$name]['cnt'] + $stats['cnt'];
      $into[$name]['time'] = bcadd(@$into[$name]['time'], @$stats['time'], perf_precision());
    }
    return $into;
  }

}

class serverproxy {
  var $url;
  var $client;
  var $curl;

  function serverproxy($url, $client=false) {
    $this->url = $url;
    $this->client = $client;
  }

  function getcurl() {
    $curl = $this->curl;
    if (!$curl) {
      $curl = new curl();
      $this->curl = $curl;
    }
    return $curl;
  }

  // From http://us.php.net/manual/en/function.stream-context-create.php#72017
  // May be able to optimize this (with keep-alive) by using the cURL functions
  function post($url, $data=array()) {
    $curl = $this->getcurl();
    return $curl->post($url, $data);
  }

  function process($msg) {
    $url = $this->url;
    $client = $this->client;
    $db = $client->db;

    // This is a kluge to get around versions of Apache that insist
    // on sending "301 Moved Permanently" for directory URLs that
    // are missing a trailing slash.
    // file_get_contents doesn't resend the post data in that case
    // This will break URLs that are to files intead of directories.
    // As part of adding a bank, I should really do the raw send without
    // params and see if I get a 301.
    if (substr($url,-1) != '/') $url = $url .= '/';

    $vars = array('msg' => $msg);

    $debugfile = '';
    if ($client->showprocess) {
      $vars['debugmsgs'] = 'true';
    }

    $dbgmsg = $this->trimmsg($msg);
    $client->debugmsg("<b>===SENT</b>: $dbgmsg\n");

    $res = $this->post($url, $vars);

    if (substr($res, 0, 2) == '<<') {
      $pos = strpos($res, ">>\n");
      if ($pos === FALSE) $text = '';
      else {
        $text = substr($res, 2, $pos-2);
        $res = substr($res, $pos+3);
      }
      if ($text) {
        $db->put($debugfile, '');
        $marker = "===times===\n";
        $pos = strpos($text, $marker);
        if (!($pos === FALSE)) {
          $times = @unserialize(substr($text, $pos + strlen($marker)));
          if ($times) $client->accumulate_server_times($times);
          $text = substr($text, 0, $pos);
        }
        if ($text) $client->debugmsg("<b>===SERVER SAID</b>: $text");
      }
    }
    
    $dbgres = $this->trimmsg($res);
    $client->debugmsg("<b>===RETURNED</b>: $dbgres\n");

    return $res;
  }

  function trimmsg($msg) {
    $client = $this->client;

    if ($client->showprocess) {
      $parser = $client->parser;
      $msg = $parser->remove_signatures($msg);
      $tokens = $parser->tokenize($msg);
      $res = '';
      foreach ($tokens as $token) {
        if (strlen($token) == 1) $res .= $token;
        elseif ($this->ishex($token)) {
          $res .= $token;
        } else {
          $res .= "<b>$token</b>";
        }
      }
      return $res;
    }
    return $msg;
  }

  function ishex($str) {
    $len = strlen($str);
    for ($i=0; $i<$len; $i++) {
      $c = substr($str, $i, 1);
      if (strpos("0123456789abcdef", $c) === FALSE) return false;
    }
    return true;
  }
}
||#

;; Look up a public key, from the client database first, then from the
;; current bank.
(defclass pubkeydb ()
  ((client :type client
           :initarg :client
           :accessor client)
   (db :type db
       :initarg :db
       :accessor db)))

(defvar *insidep* nil)

(defmethod db-get ((pubkeydb pubkeydb) id &rest more-keys)
  (assert (null more-keys))
  (let ((res (db-get (db pubkeydb) id)))
    (cond (res res)
          (*insidep* nil)
          (t (let ((*insidep* t))
               (get-pubkey-from-server (client pubkeydb) id))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Copyright 2009 Bill St. Clair
;;;
;;; Licensed under the Apache License, Version 2.0 (the "License");
;;; you may not use this file except in compliance with the License.
;;; You may obtain a copy of the License at
;;;
;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;
;;; Unless required by applicable law or agreed to in writing, software
;;; distributed under the License is distributed on an "AS IS" BASIS,
;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;; See the License for the specific language governing permissions
;;; and limitations under the License.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
